<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>使用Jasmine编写测试套件 :: Testing Angular</title>
    <meta name="generator" content="Antora 3.1.14">
    <link rel="stylesheet" href="../../_/css/site.css">
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">Testing Angular</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs-testing-angular" data-version="中文">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="introduction.html">简介</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="target-audience.html">目标受众</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="terminology.html">术语</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-principles.html">测试原则</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="example-applications.html">示例应用程序</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="angular-testing-principles.html">Angular 测试原则</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="test-suites-with-jasmine.html">使用Jasmine编写测试套件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="faking-dependencies.html">伪造依赖</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="debugging-tests.html">调试测试</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components.html">测试组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components-with-children.html">测试带有子组件的组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components-depending-on-services.html">测试依赖于服务的组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-complex-forms.html">测试复杂表单</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components-with-spectator.html">测试时使用Spectator库简化组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-services.html">测试服务</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-pipes.html">测试管道</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-directives.html">测试指令</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-modules.html">测试模块</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="measuring-code-coverage.html">代码覆盖率测量</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="end-to-end-testing.html">端到端测试</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="summary.html">总结</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index-of-example-applications.html">示例应用程序索引</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="references.html">参考资料</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="acknowledgements.html">鸣谢</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="about.html">关于</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="license.html">许可证</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="other.html">其它</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Testing Angular</span>
    <span class="version">中文</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="start.html">Testing Angular</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="start.html">中文</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="start.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="start.html">Testing Angular</a></li>
    <li><a href="test-suites-with-jasmine.html">使用Jasmine编写测试套件</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="目录" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">使用Jasmine编写测试套件</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>学习目标</p>
</div>
<div class="ulist">
<ul>
<li>
<p>介绍Jasmine测试框架</p>
</li>
<li>
<p>编写测试套件、规范和断言</p>
</li>
<li>
<p>使用"安排（Arrange）、行动（Act）、断言（Assert）"结构组织规范</p>
</li>
<li>
<p>使用初始化（setup）和销毁（teardown）逻辑创建高效的测试套件</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Angular内置了Jasmine，这是一个JavaScript框架，可以编写和执行单元测试和集成测试。Jasmine由三个重要部分组成：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一个包含用于构建测试的类和函数的库。</p>
</li>
<li>
<p>一个测试执行引擎。</p>
</li>
<li>
<p>一个将测试结果以不同格式输出的报告引擎。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果您对Jasmine还不熟悉，建议阅读 <a href="https://jasmine.github.io/tutorials/your_first_suite">官方的Jasmine教程</a>。本指南对Jasmine进行了简要介绍，探讨了在本指南中将使用的基本结构和术语。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_创建一个测试套件"><a class="anchor" href="#_创建一个测试套件"></a>创建一个测试套件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在Jasmine中，测试由一个或多个 <code>套件</code> 组成。使用 <code>describe</code> 块声明一个套件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('Suite description', () =&gt; {
  /* … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个套件 <em>描述</em> 了一段代码，即 <em>被测试的代码</em>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>describe</code>: 套件
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>describe</code> 是一个接受两个参数的函数。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一个可读性强的字符串，通常是被测试的函数或类的名称。例如，<code>describe('CounterComponent', /* … */)</code> 是测试 <code>CounterComponent</code> 类的套件。</p>
</li>
<li>
<p>一个包含套件定义的函数。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>describe</code> 块将相关的规范（specs）分组，我们将在下一章节学习。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
嵌套 <code>describe</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以嵌套 <code>describe</code> 块以便将大的套件结构化，并将其分成逻辑上的部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('Suite description', () =&gt; {
  describe('One aspect', () =&gt; {
    /* … */
  });
  describe('Another aspect', () =&gt; {
    /* … */
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>嵌套的 <code>describe</code> 块为一组规范（specs）添加了可读性强的描述。它们还可以拥有自己的初始化（setup）和销毁（teardown）逻辑。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_规范specifications"><a class="anchor" href="#_规范specifications"></a>规范（Specifications）</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>it</code>: Spec
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>每个套件由一个或多个 <em>规范(specifications)</em> 组成，简称规范（<code>specs</code>）。使用 <code>it</code> 块声明一个规范：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('Suite description', () =&gt; {
  it('Spec description', () =&gt; {
    /* … */
  });
  /* … more specs …  */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次强调，<code>it</code> 是一个函数，接受两个参数。第一个参数是一个可读性强的字符串，描述规范（spec）。第二个参数是一个包含规范代码的函数。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
可读性强的句子
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>代词 <code>it</code> 指的是被测试的代码。<code>it</code> 应该是一个可读性强的句子的主语，用于断言被测试代码的行为。然后规范代码通过实现这个断言来证明其正确性。这种编写规范的风格源于行为驱动开发（Behavior-Driven Development, BDD）的概念。</p>
</div>
<div class="paragraph">
<p>BDD 的一个目标是以自然语言（在本例中是英语）描述软件行为。每个利益相关者都应该能够阅读 <code>it</code> 句子，并理解代码应该如何运行。没有 JavaScript 知识的团队成员应该能够通过构造 <code>it does something</code> 的句子来添加更多需求。</p>
</div>
<div class="paragraph">
<p>问问自己，被测试的代码做了什么？例如，对于一个 <code>CounterComponent</code>，<em>it</em> 增加了计数器的值。并且 <em>it</em> 将计数器重置为特定的值。因此，您可以编写以下句子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('increments the count', () =&gt; {
  /* … */
});
it('resets the count', () =&gt; {
  /* … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>it</code> 块之后，通常会跟随一个动词，例如在示例中的 <code>increments</code> 和 <code>resets</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
不使用 “should”
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有些人喜欢写成 <code>it('should increment the count', /* … */)</code>，但是 <code>should</code> 并没有额外的含义。规范的本质是陈述被测试代码应该做什么。使用 <em>should</em> 这个词只会增加冗余，让句子变得更长。本指南建议简单陈述代码的行为。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://jasmine.github.io/tutorials/your_first_suite">Jasmine 教程：你的第一个套件</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_测试的结构"><a class="anchor" href="#_测试的结构"></a>测试的结构</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 <code>it</code> 块内部是实际的测试代码。不论测试框架如何，测试代码通常包括三个阶段：<strong>安排（Arrange）、行动（Act）和断言（Assert）</strong>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
安排、行动、断言
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Arrange</strong> 是准备和设置阶段。例如，被测试的类被实例化，依赖项被设置，间谍（spies）和伪装（fakes）被创建。</p>
</li>
<li>
<p><strong>Act</strong> 是与被测试代码进行交互的阶段。例如，调用一个方法或点击 DOM 中的一个 HTML 元素。</p>
</li>
<li>
<p><strong>Assert</strong> 是检查和验证代码行为的阶段。例如，将实际输出与预期输出进行比较。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>针对 <code>CounterComponent</code> 的规范 <code>it('resets the count', /* … */)</code> 的结构可以是什么样子呢？</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Arrange</strong>：</p>
<div class="ulist">
<ul>
<li>
<p>创建一个 <code>CounterComponent</code> 的实例。</p>
</li>
<li>
<p>将组件渲染到文档中。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Act:</strong></p>
<div class="ulist">
<ul>
<li>
<p>找到并聚焦重置输入字段。</p>
</li>
<li>
<p>输入文本“5”。</p>
</li>
<li>
<p>找到并点击“重置”按钮。</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Assert:</strong></p>
<div class="ulist">
<ul>
<li>
<p>期望显示的计数现在为“5”。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
组织一个测试
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这个结构使得编写和实现测试更加容易。问问自己：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>需要哪些设置？我需要提供哪些依赖项？它们的行为是怎样的？（<em>Arrange</em>）</p>
</li>
<li>
<p>哪些用户输入或 API 调用会触发我想要测试的行为？（<em>Act</em>）</p>
</li>
<li>
<p>期望的行为是什么？如何证明这个行为是正确的？（<em>Assert</em>）</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Given, When, Then
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在行为驱动开发（Behavior-Driven Development BDD）中，测试的三个阶段本质上是相同的。但它们被称为 <strong>给定（Given）、当（When）和那么（Then）</strong>。这些简单的英语单词试图避免技术术语，并提供了一种自然的思考测试结构的方式：“<em>给定(Given)</em> 这些条件，<em>当(when)</em> 用户与应用程序交互时，<em>那么(then)</em> 它会以某种方式表现。”</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_期望"><a class="anchor" href="#_期望"></a>期望</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 <em>断言</em> 阶段，测试将实际输出或返回值与期望的输出或返回值进行比较。如果它们相同，测试通过。如果它们不同，测试失败。</p>
</div>
<div class="paragraph">
<p>让我们来看一个简单的人为示例，一个 <code>add</code> 函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const add = (a, b) =&gt; a + b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个没有任何测试工具的原始测试可以是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const expectedValue = 5;
const actualValue = add(2, 3);
if (expectedValue !== actualValue) {
  throw new Error(
    `Wrong return value: ${actualValue}. Expected: ${expectedValue}`
  );
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>expect</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们可以在 Jasmine 规范中编写该代码，但是 Jasmine 允许我们以一种更简单、更简洁的方式创建期望值：使用 <strong>expect</strong> 函数和匹配器（<strong>matcher</strong>）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const expectedValue = 5;
const actualValue = add(2, 3);
expect(actualValue).toBe(expectedValue);</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们将实际值传递给 <code>expect</code> 函数。它返回一个期望对象，其中包含用于检查实际值的方法。我们想要将实际值与期望值进行比较，因此我们使用了 <code>toBe</code> 匹配器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
匹配器（Matchers）
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>toBe</code> 是适用于所有可能的 JavaScript 值的最简单的匹配器。它在内部使用了 JavaScript 的严格相等运算符 <code>===</code>。<code>expect(actualValue).toBe(expectedValue)</code> 本质上运行的是 <code>actualValue === expectedValue</code>。</p>
</div>
<div class="paragraph">
<p><code>toBe</code> 适用于比较字符串、数字和布尔值等基本类型。对于对象，<code>toBe</code> 仅在实际值和期望值完全相同的对象时匹配。即使两个对象恰好具有相同的属性和值，如果它们不是完全相同的对象，<code>toBe</code> 会失败。</p>
</div>
<div class="paragraph">
<p>如果要检查两个对象的深层相等性，Jasmine 提供了 <code>toEqual</code> 匹配器。下面的示例说明了它们之间的区别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">// Fails, the two objects are not identical
expect({ name: 'Linda' }).toBe({ name: 'Linda' });

// Passes, the two objects are not identical but deeply equal
expect({ name: 'Linda' }).toEqual({ name: 'Linda' });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jasmine内置了许多有用的匹配器，其中 <code>toBe</code> 和 <code>toEqual</code> 是最常用的。您可以添加自定义匹配器，将复杂的检查隐藏在一个简短的名称后面。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
可读的句子
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>模式 <code>expect(actualValue).toEqual(expectedValue)</code> 再次源自行为驱动开发（BDD）。<code>expect</code> 函数调用和匹配器方法形成了一个可读的句子：“期望实际值等于期望值”。目标是编写一个规范，它像纯文本一样可读，但可以自动验证。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://jasmine.github.io/api/edge/matchers">Jasmine 文档：内置的匹配器</a></p>
</li>
<li>
<p><a href="https://jasmine.github.io/tutorials/custom_matcher">Jasmine 教程：自定义匹配器</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_高效的测试套件"><a class="anchor" href="#_高效的测试套件"></a>高效的测试套件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在一个套件中编写多个规范时，您很快会意识到 <em>Arrange</em> 阶段在这些规范中是相似或甚至相同的。例如，当测试 <code>CounterComponent</code> 时， <em>Arrange</em> 阶段始终包括创建一个组件实例并将其渲染到文档中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
重复的设置
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这种设置反复出现，因此应该在一个中心位置定义一次。您可以编写一个 <code>setup</code> 函数，并在每个规范的开头调用它。但是使用 Jasmine，您可以声明在每个规范之前和之后，或在所有规范之前和之后调用的代码。</p>
</div>
<div class="paragraph">
<p>为实现这个目的，Jasmine 为我们提供了四个函数：<code>beforeEach</code>、<code>afterEach</code>、<code>beforeAll</code> 和 <code>afterAll</code>。它们在 <code>describe</code> 块内部调用，就像 <code>it</code> 一样。它们都接受一个参数，即在给定阶段调用的函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('Suite description', () =&gt; {
  beforeAll(() =&gt; {
    console.log('Called before all specs are run');
  });
  afterAll(() =&gt; {
    console.log('Called after all specs are run');
  });

  beforeEach(() =&gt; {
    console.log('Called before each spec is run');
  });
  afterEach(() =&gt; {
    console.log('Called after each spec is run');
  });

  it('Spec 1', () =&gt; {
    console.log('Spec 1');
  });
  it('Spec 2', () =&gt; {
    console.log('Spec 2');
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个套件有两个规范，并定义了共享的初始化（setup）和销毁（teardown）代码。输出结果如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Called before all specs are run
Called before each spec is run
Spec 1
Called after each spec is run
Called before each spec is run
Spec 2
Called after each spec is run
Called after all specs are run</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们要编写的大多数测试都将包含一个 <code>beforeEach</code> 块来承载安排（<em>Arrange</em>）代码。</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
