<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>测试时使用Spectator库简化组件 :: Testing Angular</title>
    <meta name="generator" content="Antora 3.1.14">
    <link rel="stylesheet" href="../../_/css/site.css">
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">Testing Angular</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs-testing-angular" data-version="中文">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="introduction.html">简介</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="target-audience.html">目标受众</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="terminology.html">术语</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-principles.html">测试原则</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="example-applications.html">示例应用程序</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="angular-testing-principles.html">Angular 测试原则</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="test-suites-with-jasmine.html">使用Jasmine编写测试套件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="faking-dependencies.html">伪造依赖</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="debugging-tests.html">调试测试</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components.html">测试组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components-with-children.html">测试带有子组件的组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components-depending-on-services.html">测试依赖于服务的组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-complex-forms.html">测试复杂表单</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="testing-components-with-spectator.html">测试时使用Spectator库简化组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-services.html">测试服务</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-pipes.html">测试管道</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-directives.html">测试指令</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-modules.html">测试模块</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="measuring-code-coverage.html">代码覆盖率测量</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="end-to-end-testing.html">端到端测试</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="summary.html">总结</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index-of-example-applications.html">示例应用程序索引</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="references.html">参考资料</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="acknowledgements.html">鸣谢</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="about.html">关于</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="license.html">许可证</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="other.html">其它</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Testing Angular</span>
    <span class="version">中文</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="start.html">Testing Angular</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="start.html">中文</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="start.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="start.html">Testing Angular</a></li>
    <li><a href="testing-components-with-spectator.html">测试时使用Spectator库简化组件</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="目录" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">测试时使用Spectator库简化组件</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>学习目标：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用Spectator库简化组件测试</p>
</li>
<li>
<p>使用统一的Spectator接口</p>
</li>
<li>
<p>与组件和渲染的DOM进行交互</p>
</li>
<li>
<p>发送合成DOM事件以模拟用户输入</p>
</li>
<li>
<p>使用Spectator和ng-mocks来伪造子组件和服务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们使用了Angular的测试工具来设置模块、渲染组件、查询DOM等等。这些工具包括<code>TestBed</code>、<code>ComponentFixture</code>和<code>DebugElement</code>，也包括<code>HttpClientTestingModule</code>和<code>RouterTestingModule</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
结构性弱点
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>内置工具比较低级和没有明确的意见。它们有几个缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TestBed</code>需要大量的样板代码来设置一个常见的组件或服务测试。</p>
</li>
<li>
<p><code>DebugElement</code>缺少必要的功能，是一个“泄漏”的抽象。你被迫使用包装的本地DOM元素来处理常见任务。</p>
</li>
<li>
<p>没有默认的解决方案来安全地伪造组件和服务依赖。</p>
</li>
<li>
<p>测试本身变得冗长和重复。你必须建立测试约定并自己编写帮助程序。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们已经使用了小型 <a href="testing-components.html#_测试辅助函数" class="xref page">元素测试辅助函数</a>。它们解决了隔离问题，以便编写更一致和紧凑的规范。</p>
</div>
<div class="paragraph">
<p>如果你编写数百或数千个规范，你会发现这些帮助函数不够。它们没有解决上述结构性问题。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
统一测试API
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong><a href="https://github.com/ngneat/spectator">Spectator</a></strong> 是一个用于测试Angular应用程序的有意见的库。从技术上讲，它位于<code>TestBed</code>、<code>ComponentFixture</code>和<code>DebugElement</code>之上。但主要思想是在一个一致、强大和用户友好的接口<code>Spectator</code>对象中统一所有这些API。</p>
</div>
<div class="paragraph">
<p>Spectator简化了测试组件、服务、指令、管道、路由和HTTP通信。Spectator的优势是具有输入、输出、子项、事件处理、服务依赖等组件测试。</p>
</div>
<div class="paragraph">
<p>对于 <a href="testing-components-with-children.html#_使用_ng_mocks_伪造子组件" class="xref page">伪造子组件</a>，Spectator采用了ng-mocks库，就像我们一样。</p>
</div>
<div class="paragraph">
<p>本指南无法介绍所有Spectator功能，但我们将讨论使用Spectator进行组件测试的基础知识。</p>
</div>
<div class="paragraph">
<p>两个 <a href="example-applications.html#_示例应用程序" class="xref page">示例应用程序</a> 都使用我们的元素帮助程序进行测试，也使用Spectator进行测试。前面的规范使用后缀<code>.spec.ts</code>，而后者使用后缀<code>.spectator.spec.ts</code>。这样，您可以将测试并排进行比较。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将讨论使用Spectator测试Flickr搜索。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_具有输入的组件"><a class="anchor" href="#_具有输入的组件"></a>具有输入的组件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>让我们从 <a href="https://github.com/9elements/angular-flickr-search/tree/main/src/app/components/full-photo"><code>FullPhotoComponent</code></a>开始，因为它是一个 <a href="testing-components-with-children.html#_测试带有子组件的组件" class="xref page">展示组件</a>，是组件树中的叶子。它期望一个照片对象作为输入，并渲染 <code>图像(Photo)</code> 以及照片元数据。没有输出、没有子项、没有服务依赖。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/9elements/angular-flickr-search/blob/main/src/app/components/full-photo/full-photo.component.spec.ts"><code>FullPhotoComponent</code> 套件使用我们的帮助程序</a> 如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('FullPhotoComponent', () =&gt; {
  let component: FullPhotoComponent;
  let fixture: ComponentFixture&lt;FullPhotoComponent&gt;;

  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      declarations: [FullPhotoComponent],
      schemas: [NO_ERRORS_SCHEMA],
    }).compileComponents();

    fixture = TestBed.createComponent(FullPhotoComponent);
    component = fixture.componentInstance;
    component.photo = photo1;
    fixture.detectChanges();
  });

  it('renders the photo information', () =&gt; {
    expectText(fixture, 'full-photo-title', photo1.title);

    const img = findEl(fixture, 'full-photo-image');
    expect(img.properties.src).toBe(photo1.url_m);
    expect(img.properties.alt).toBe(photo1.title);

    expectText(fixture, 'full-photo-ownername', photo1.ownername);
    expectText(fixture, 'full-photo-datetaken', photo1.datetaken);
    expectText(fixture, 'full-photo-tags', photo1.tags);

    const link = findEl(fixture, 'full-photo-link');
    expect(link.properties.href).toBe(photo1Link);
    expect(link.nativeElement.textContent.trim()).toBe(photo1Link);
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个套件已经使用了<code>expectText</code>和<code>findEl</code>，但是仍然使用了不太可靠的<code>DebugElement</code>抽象。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
组件工厂
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在使用Spectator时，模块配置和组件创建的方式不同。在测试套件的范围内，我们创建一个<strong>组件工厂</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { createComponentFactory } from '@ngneat/spectator';

describe('FullPhotoComponent with spectator', () =&gt; {
  /* … */

  const createComponent = createComponentFactory({
    component: FullPhotoComponent,
    shallow: true,
  });

  /* … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>createComponentFactory</code>期望一个配置对象。<code>component: FullPhotoComponent</code>指定要测试的组件。shallow: true表示我们想要 <a href="testing-components-with-children.html#_浅渲染_vs_深渲染" class="xref page">浅层渲染，而不是深层渲染</a>。但是对于<code>FullPhotoComponent</code>来说没有区别，因为它没有子元素。</p>
</div>
<div class="paragraph">
<p>配置对象可以包括更多用于测试模块的选项，稍后我们将看到。</p>
</div>
<div class="paragraph">
<p>在内部，<code>createComponentFactory</code>创建了一个<code>beforeEach</code>块，该块调用<code>TestBed.configureTestingModule</code>和<code>TestBed.compileComponents</code>，就像我们手动做的那样。</p>
</div>
<div class="paragraph">
<p><code>createComponentFactory</code>返回一个用于创建<code>FullPhotoComponent</code>的工厂函数。我们将该函数保存在<code>createComponent</code>常量中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
创建组件
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下一步是添加一个<code>beforeEach</code>块，该块创建组件实例。<code>createComponent</code>再次接受一个选项对象。为了设置<code>photo</code>输入属性，我们传递 <code>props: { photo: photo1 }</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { createComponentFactory, Spectator } from '@ngneat/spectator';

describe('FullPhotoComponent with spectator', () =&gt; {
  let spectator: Spectator&lt;FullPhotoComponent&gt;;

  const createComponent = createComponentFactory({
    component: FullPhotoComponent,
    shallow: true,
  });

  beforeEach(() =&gt; {
    spectator = createComponent({ props: { photo: photo1 } });
  });

  /* … */
});</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spectator
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>createComponent</code>返回一个<code>Spectator</code>对象。这是我们将在规范中使用的强大接口。</p>
</div>
<div class="paragraph">
<p>规范 <code>it('renders the photo information', /* … */)</code> 多次重复了三个关键任务：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过测试ID查找元素</p>
</li>
<li>
<p>检查其文本内容</p>
</li>
<li>
<p>检查其属性值</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>首先，规范找到具有测试ID <code>full-photo-title</code>的元素，并期望它包含照片的标题。</p>
</div>
<div class="paragraph">
<p>使用Spectator，它看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">expect(
  spectator.query(byTestId('full-photo-title'))
).toHaveText(photo1.title);</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>spectator.query</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>中心的<code>spectator.query</code>方法在DOM中查找元素。本指南建议 <a href="testing-components.html#_使用测试_id_查询_dom" class="xref page">通过测试ID（<code>data-testid</code>属性）查找元素</a>。</p>
</div>
<div class="paragraph">
<p>Spectator支持测试ID，所以我们可以写成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">spectator.query(byTestId('full-photo-title'))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>spectator.query</code>返回一个本地DOM元素，如果没有找到匹配项，则返回<code>null</code>。请注意，它不返回<code>DebugElement</code>。</p>
</div>
<div class="paragraph">
<p>使用Spectator时，您直接使用DOM元素对象进行操作。乍一看似乎很麻烦，但实际上却减轻了泄漏的<code>DebugElement</code>抽象的负担。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Jasmine匹配器
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spectator使得使用普通DOM元素非常容易。Jasmine添加了几个匹配器，可以对元素进行期望。</p>
</div>
<div class="paragraph">
<p>为了检查元素的文本内容，Spectator提供了<code>toHaveText</code>匹配器。这将导致我们有以下期望：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">expect(
  spectator.query(byTestId('full-photo-title'))
).toHaveText(photo1.title);</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码等同于我们的<code>expectText</code>助手，但更符合惯用语并且更易于阅读。</p>
</div>
<div class="paragraph">
<p>接下来，我们需要验证组件使用<code>img</code>元素呈现完整的照片。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const img = spectator.query(byTestId('full-photo-image'));
expect(img).toHaveAttribute('src', photo1.url_m);
expect(img).toHaveAttribute('alt', photo1.title);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们找到了具有测试ID <code>full-photo-image</code>的元素，以检查其<code>src</code>和<code>alt</code>属性。我们使用Spectator的匹配器<code>toHaveAttribute</code>来实现此目的。</p>
</div>
<div class="paragraph">
<p>规格说明的其余部分找到更多元素以检查其内容和属性。</p>
</div>
<div class="paragraph">
<p>使用Spectator的完整测试套件（仅显示来自Spectator的导入）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import {
  byTestId, createComponentFactory, Spectator
} from '@ngneat/spectator';

describe('FullPhotoComponent with spectator', () =&gt; {
  let spectator: Spectator&lt;FullPhotoComponent&gt;;

  const createComponent = createComponentFactory({
    component: FullPhotoComponent,
    shallow: true,
  });

  beforeEach(() =&gt; {
    spectator = createComponent({ props: { photo: photo1 } });
  });

  it('renders the photo information', () =&gt; {
    expect(
      spectator.query(byTestId('full-photo-title'))
    ).toHaveText(photo1.title);

    const img = spectator.query(byTestId('full-photo-image'));
    expect(img).toHaveAttribute('src', photo1.url_m);
    expect(img).toHaveAttribute('alt', photo1.title);

    expect(
      spectator.query(byTestId('full-photo-ownername'))
    ).toHaveText(photo1.ownername);
    expect(
      spectator.query(byTestId('full-photo-datetaken'))
    ).toHaveText(photo1.datetaken);
    expect(
      spectator.query(byTestId('full-photo-tags'))
    ).toHaveText(photo1.tags);

    const link = spectator.query(byTestId('full-photo-link'));
    expect(link).toHaveAttribute('href', photo1Link);
    expect(link).toHaveText(photo1Link);
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>与具有自定义测试助手版本相比，Spectator版本不一定更短。但它在 <em>一致的抽象级别上</em> 工作。</p>
</div>
<div class="paragraph">
<p>不再有<code>TestBed</code>，<code>ComponentFixture</code>，<code>DebugElement</code>和助手函数的混合，而是有<code>createComponentFactory</code>函数和一个<code>Spectator</code>实例。</p>
</div>
<div class="paragraph">
<p>Spectator避免包装DOM元素，但为常见的DOM期望提供了方便的Jasmine匹配器。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-flickr-search/tree/main/src/app/components/full-photo">FullPhotoComponent：实现代码和两个测试</a></p>
</li>
<li>
<p><a href="https://github.com/ngneat/spectator#queries">Spectator：查询</a></p>
</li>
<li>
<p><a href="https://github.com/ngneat/spectator#custom-matchers">Spectator：自定义匹配器</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_具有子项和服务依赖项的组件"><a class="anchor" href="#_具有子项和服务依赖项的组件"></a>具有子项和服务依赖项的组件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在测试 <a href="testing-components-with-children.html#_测试带有子组件的组件" class="xref page">容器组件</a> 时，Spectator真正发挥作用。这些是具有子项和服务依赖项的组件。</p>
</div>
<div class="paragraph">
<p>在Flickr搜索中，最上层的 <a href="https://github.com/9elements/angular-flickr-search/tree/main/src/app/components/flickr-search"><code>FlickrSearchComponent</code></a> 调用<code>FlickrService</code>并保存状态。它协调其他三个组件，传递状态并监听输出。</p>
</div>
<div class="paragraph">
<p><code>FlickrSearchComponent</code>模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;app-search-form (search)="handleSearch($event)"&gt;&lt;/app-search-form&gt;

&lt;div class="photo-list-and-full-photo"&gt;
  &lt;app-photo-list
    [title]="searchTerm"
    [photos]="photos"
    (focusPhoto)="handleFocusPhoto($event)"
    class="photo-list"
  &gt;&lt;/app-photo-list&gt;

  &lt;app-full-photo
    *ngIf="currentPhoto"
    [photo]="currentPhoto"
    class="full-photo"
    data-testid="full-photo"
  &gt;&lt;/app-full-photo&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>FlickrSearchComponent</code> 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">@Component({
  selector: 'app-flickr-search',
  templateUrl: './flickr-search.component.html',
  styleUrls: ['./flickr-search.component.css'],
})
export class FlickrSearchComponent {
  public searchTerm = '';
  public photos: Photo[] = [];
  public currentPhoto: Photo | null = null;

  constructor(private flickrService: FlickrService) {}

  public handleSearch(searchTerm: string): void {
    this.flickrService.searchPublicPhotos(searchTerm).subscribe(
      (photos) =&gt; {
        this.searchTerm = searchTerm;
        this.photos = photos;
        this.currentPhoto = null;
      }
    );
  }

  public handleFocusPhoto(photo: Photo): void {
    this.currentPhoto = photo;
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
子组件
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>由于这是汇聚所有事物的组件，因此需要进行大量测试。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>最初，渲染的是<code>SearchFormComponent</code>和<code>PhotoListComponent</code>，而不是<code>FullPhotoComponent</code>。照片列表为空。</p>
</li>
<li>
<p>当<code>SearchFormComponent</code>发出 <code>search</code> 输出时，使用搜索词调用<code>FlickrService</code>。</p>
</li>
<li>
<p>搜索词和照片列表通过输入传递到<code>PhotoListComponent</code>。</p>
</li>
<li>
<p>当<code>PhotoListComponent</code>发出<code>focusPhoto</code>输出时，渲染<code>FullPhotoComponent</code>。所选照片通过输入传递下来。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
没有Spectator
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用我们的助手程序的 <a href="https://github.com/9elements/angular-flickr-search/blob/main/src/app/components/flickr-search/flickr-search.component.spec.ts"><code>FlickrSearchComponent</code></a> 测试套件如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('FlickrSearchComponent', () =&gt; {
  let fixture: ComponentFixture&lt;FlickrSearchComponent&gt;;
  let component: FlickrSearchComponent;
  let fakeFlickrService: Pick&lt;FlickrService, keyof FlickrService&gt;;

  let searchForm: DebugElement;
  let photoList: DebugElement;

  beforeEach(async () =&gt; {
    fakeFlickrService = {
      searchPublicPhotos: jasmine
        .createSpy('searchPublicPhotos')
        .and.returnValue(of(photos)),
    };

    await TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      declarations: [FlickrSearchComponent],
      providers: [
        { provide: FlickrService, useValue: fakeFlickrService }
      ],
      schemas: [NO_ERRORS_SCHEMA],
    }).compileComponents();
  });

  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(FlickrSearchComponent);
    component = fixture.debugElement.componentInstance;
    fixture.detectChanges();

    searchForm = findComponent(fixture, 'app-search-form');
    photoList = findComponent(fixture, 'app-photo-list');
  });

  it('renders the search form and the photo list, not the full photo', () =&gt; {
    expect(searchForm).toBeTruthy();
    expect(photoList).toBeTruthy();
    expect(photoList.properties.title).toBe('');
    expect(photoList.properties.photos).toEqual([]);

    expect(() =&gt; {
      findComponent(fixture, 'app-full-photo');
    }).toThrow();
  });

  it('searches and passes the resulting photos to the photo list', () =&gt; {
    const searchTerm = 'beautiful flowers';
    searchForm.triggerEventHandler('search', searchTerm);
    fixture.detectChanges();

    expect(fakeFlickrService.searchPublicPhotos).toHaveBeenCalledWith(searchTerm);
    expect(photoList.properties.title).toBe(searchTerm);
    expect(photoList.properties.photos).toBe(photos);
  });

  it('renders the full photo when a photo is focussed', () =&gt; {
    expect(() =&gt; {
      findComponent(fixture, 'app-full-photo');
    }).toThrow();

    photoList.triggerEventHandler('focusPhoto', photo1);

    fixture.detectChanges();

    const fullPhoto = findComponent(fixture, 'app-full-photo');
    expect(fullPhoto.properties.photo).toBe(photo1);
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过多详细说明，以下是一些注释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们使用 <a href="testing-components-with-children.html#_浅渲染_vs_深渲染" class="xref page">浅渲染</a> 。子组件未声明，只渲染空的外壳元素（<code>app-search-form</code>、<code>app-photo-list</code>和<code>app-full-photo</code>）。这使我们可以检查它们的存在、它们的输入和输出。</p>
</li>
<li>
<p>我们使用我们的<code>findComponent</code>测试助手来查找子元素。</p>
</li>
<li>
<p>要检查输入值，我们使用<code>DebugElement</code>的 <code>properties</code>。</p>
</li>
<li>
<p>要模拟输出发出，我们在<code>DebugElement</code>上使用<code>triggerEventListener</code>。</p>
</li>
<li>
<p>我们提供自己的虚假<code>FlickrService</code>。它包含一个Jasmine间谍，返回一个带有固定照片列表的Observable。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">  fakeFlickrService = {
    searchPublicPhotos: jasmine
      .createSpy('searchPublicPhotos')
      .and.returnValue(of(photos)),
  };</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
使用 Spectator
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用Spectator重写这个套件带来了两个主要变化：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>我们使用 <a href="testing-components-with-children.html#_使用_ng_mocks_伪造子组件" class="xref page">ng-mocks</a> 创建虚假的子组件来替换子组件。虚假的组件在其输入和输出方面模仿原始组件，但它们不会渲染任何内容。我们将使用这些组件实例来代替在<code>DebugElement</code>上操作。</p>
</li>
<li>
<p>我们使用Spectator创建虚假的<code>FlickrService</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>测试套件设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import {
  createComponentFactory, mockProvider, Spectator
} from '@ngneat/spectator';

describe('FlickrSearchComponent with spectator', () =&gt; {
  /* … */

  const createComponent = createComponentFactory({
    component: FlickrSearchComponent,
    shallow: true,
    declarations: [
      MockComponents(
        SearchFormComponent, PhotoListComponent, FullPhotoComponent
      ),
    ],
    providers: [mockProvider(FlickrService)],
  });

  /* … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次，我们使用Spectator的<code>createComponentFactory</code>。这次，我们使用ng-mocks的<code>MockComponents</code>函数用虚拟子组件替换子组件。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>mockProvider</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后，我们使用Spectator的<code>mockProvider</code>函数创建一个假的<code>FlickrService</code>。在底层，这与我们手动创建的<code>fakeFlickrService</code>大致相同。它创建一个类似于原始对象的对象，但方法被替换为Jasmine间谍。</p>
</div>
<div class="paragraph">
<p>在<code>beforeEach</code>块中创建组件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import {
  createComponentFactory, mockProvider, Spectator
} from '@ngneat/spectator';

describe('FlickrSearchComponent with spectator', () =&gt; {
  let spectator: Spectator&lt;FlickrSearchComponent&gt;;

  let searchForm: SearchFormComponent | null;
  let photoList: PhotoListComponent | null;
  let fullPhoto: FullPhotoComponent | null;

  const createComponent = createComponentFactory(/* … */);

  beforeEach(() =&gt; {
    spectator = createComponent();

    spectator.inject(FlickrService).searchPublicPhotos.and.returnValue(of(photos));

    searchForm = spectator.query(SearchFormComponent);
    photoList = spectator.query(PhotoListComponent);
    fullPhoto = spectator.query(FullPhotoComponent);
  });

  /* … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>spectator.inject</code>相当于<code>TestBed.inject</code>。我们获取<code>FlickrService</code>的假实例并配置<code>searchPublicPhotos</code>间谍以返回固定数据。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
查找子元素
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>spectator.query</code>不仅可以在DOM中查找元素，还可以查找子组件和其他嵌套指令。我们找到了三个子组件并将它们保存在变量中，因为它们将在所有规范中使用。</p>
</div>
<div class="paragraph">
<p>请注意，<code>searchForm</code>、<code>photoList</code>和<code>fullPhoto</code>被定义为Component实例，而不是DebugElement。这是准确的，因为假组件具有相同的公共接口、相同的输入和输出。</p>
</div>
<div class="paragraph">
<p>由于 <a href="faking-dependencies.html#_伪造物和原始物的等价性" class="xref page">伪造物和原始组件的等价性</a>，我们可以使用模式<code>componentInstance.input</code>访问输入。我们使用模式 <code>componentInstance.output.emit(…)</code> 让一个输出发出信号。</p>
</div>
<div class="paragraph">
<p>第一个规范检查初始状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('renders the search form and the photo list, not the full photo', () =&gt; {
  if (!(searchForm &amp;&amp; photoList)) {
    throw new Error('searchForm or photoList not found');
  }
  expect(photoList.title).toBe('');
  expect(photoList.photos).toEqual([]);
  expect(fullPhoto).not.toExist();
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>spectator.query(PhotoListComponent)</code>要么返回组件实例，要么返回<code>null</code>，如果不存在这样的嵌套组件。因此，<code>photoList</code>变量被定义为 <code>PhotoListComponent | null</code> 类型。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
手动类型保护
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>不幸的是，<code>expect</code>不是 <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html">TypeScript类型保护</a>。Jasmine的expectations无法将类型从 <code>PhotoListComponent | null</code> 缩小到 <code>PhotoListComponent</code>。</p>
</div>
<div class="paragraph">
<p>我们不能调用 <code>expect(photoList).not.toBe(null)</code> 并继续使用 <code>expect(photoList.title).toBe('')</code> 。第一个expectation在<code>null</code>情况下抛出错误，但TypeScript不知道这一点。TypeScript仍然假定类型为 <code>PhotoListComponent | null</code> ，所以它会抱怨 <code>photoList.title</code>。</p>
</div>
<div class="paragraph">
<p>这就是为什么当<code>photoList</code>为<code>null</code>时我们手动抛出一个错误。TypeScript推断在规范的其余部分中类型必须为<code>PhotoListComponent</code>。</p>
</div>
<div class="paragraph">
<p>相比之下，我们的<code>findComponent</code>帮助函数在没有匹配项时直接抛出异常，提前失败测试。为了验证是否缺少子组件，我们必须期望该异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">expect(() =&gt; {
  findComponent(fixture, 'app-full-photo');
}).toThrow();`.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spectator规范继续使用 <code>expect(fullPhoto).not.toExist()</code>，它相当于 <code>expect(fullPhoto).toBe(null)</code>。Jasmine匹配器<code>toExist</code>来自Spectator。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
测试搜索
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>第二个规范涵盖了搜索：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('searches and passes the resulting photos to the photo list', () =&gt; {
  if (!(searchForm &amp;&amp; photoList)) {
    throw new Error('searchForm or photoList not found');
  }
  const searchTerm = 'beautiful flowers';
  searchForm.search.emit(searchTerm);

  spectator.detectChanges();

  const flickrService = spectator.inject(FlickrService);
  expect(flickrService.searchPublicPhotos).toHaveBeenCalledWith(searchTerm);
  expect(photoList.title).toBe(searchTerm);
  expect(photoList.photos).toBe(photos);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>当<code>SearchFormComponent</code>发布搜索词时，我们期望<code>FlickrService</code>已被调用。此外，我们期望将搜索词和来自Service的照片列表传递给<code>PhotoListComponent</code>。</p>
</div>
<div class="paragraph">
<p><code>spectator.detectChanges()</code>只是Spectator对<code>fixture.detectChanges()</code>的快捷方式。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
测试聚焦照片
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后一个规范聚焦一张照片：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('renders the full photo when a photo is focussed', () =&gt; {
  expect(fullPhoto).not.toExist();

  if (!photoList) {
    throw new Error('photoList not found');
  }
  photoList.focusPhoto.emit(photo1);

  spectator.detectChanges();

  fullPhoto = spectator.query(FullPhotoComponent);
  if (!fullPhoto) {
    throw new Error('fullPhoto not found');
  }
  expect(fullPhoto.photo).toBe(photo1);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次强调，主要区别在于我们直接使用输入和输出。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-flickr-search/tree/main/src/app/components/flickr-search">FlickrSearchComponent：实现代码和两个测试: implementation code and the two tests</a></p>
</li>
<li>
<p><a href="https://github.com/help-me-mom/ng-mocks#how-to-create-a-mock-component">ng-mocks：如何模拟一个组件</a></p>
</li>
<li>
<p><a href="https://github.com/ngneat/spectator#mocking-providers">Spectator：模拟提供者</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用spectator处理事件"><a class="anchor" href="#_使用spectator处理事件"></a>使用Spectator处理事件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>大多数组件处理输入事件，如鼠标点击，按键或表单字段更改。为了模拟它们，我们在<code>DebugElement</code>上使用<code>triggerEventHandler</code>方法。此方法实际上不会模拟DOM事件，它只是调用由 <code>(click)="handler($event)"</code> 等注册的事件处理程序。</p>
</div>
<div class="paragraph">
<p>triggerEventHandler要求您创建一个事件对象，该对象在模板中成为 <code>$event</code> 。出于这个原因，我们引入了<code>click</code>和<code>makeClickEvent</code>助手。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
合成事件
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spectator采用了不同的方法：它分派合成的DOM事件。这使得测试更加真实。合成事件可以像真实事件一样在DOM树中冒泡。Spectator为您创建事件对象，同时您可以配置详细信息。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>spectator.click</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要执行简单的单击操作，我们使用<code>spectator.click</code>并传递目标元素或<code>byTestId</code>选择器。来自 <a href="https://github.com/9elements/angular-flickr-search/blob/main/src/app/components/photo-item/photo-item.component.spectator.spec.ts">PhotoItemComponent 测试</a> 的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('PhotoItemComponent with spectator', () =&gt; {
  /* … */

  it('focusses a photo on click', () =&gt; {
    let photo: Photo | undefined;

    spectator.component.focusPhoto.subscribe((otherPhoto: Photo) =&gt; {
      photo = otherPhoto;
    });

    spectator.click(byTestId('photo-item-link'));

    expect(photo).toBe(photo1);
  });

  /* … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个常见的任务是模拟表单字段输入。到目前为止，我们已经使用 <a href="testing-components.html#_填充表单" class="xref page">setFieldValue助手</a> 来完成此任务。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>spectator.typeInElement</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spectator有一个等效的方法称为<code>spectator.typeInElement</code>。它在 <a href="https://github.com/9elements/angular-flickr-search/blob/main/src/app/components/search-form/search-form.component.spectator.spec.ts">SearchFormComponent测试</a>中使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('SearchFormComponent with spectator', () =&gt; {
  /* … */

  it('starts a search', () =&gt; {
    let actualSearchTerm: string | undefined;

    spectator.component.search.subscribe((otherSearchTerm: string) =&gt; {
      actualSearchTerm = otherSearchTerm;
    });

    spectator.typeInElement(searchTerm, byTestId('search-term-input'));

    spectator.dispatchFakeEvent(byTestId('form'), 'submit');

    expect(actualSearchTerm).toBe(searchTerm);
  });
});</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
触发 <code>ngSubmit</code> 事件
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>该规范模拟在搜索字段中键入搜索词。然后它在 <code>表单(form)</code> 元素上模拟<code>ngSubmit</code>事件。我们使用通用方法<code>spectator.dispatchFakeEvent</code>来完成此目的。</p>
</div>
<div class="paragraph">
<p>Spectator提供了更多方便的快捷方式来触发事件。Flickr搜索Spectator测试只使用了最常见的方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-flickr-search/tree/main/src/app/components/photo-item">PhotoItemComponent：实现代码和两个测试</a></p>
</li>
<li>
<p><a href="https://github.com/9elements/angular-flickr-search/tree/main/src/app/components/search-form">SearchFormComponent：实现代码和两个测试</a></p>
</li>
<li>
<p><a href="https://github.com/ngneat/spectator#events-api">Spectator：事件API</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spectator总结"><a class="anchor" href="#_spectator总结"></a>Spectator：总结</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spectator是一个成熟的库，解决了Angular开发人员的实际需求。它为常见的Angular测试问题提供解决方案。上面的示例仅介绍了Spectator的一些功能。</p>
</div>
<div class="paragraph">
<p>测试代码应简洁易懂。Spectator为编写Angular测试提供了一种表达力强、高层次的语言。Spectator使简单的任务变得简单，而不失去任何功能。</p>
</div>
<div class="paragraph">
<p>Spectator的成功凸显了标准的Angular测试工具很麻烦而且不一致。替代概念既是必要的，也是有益的。</p>
</div>
<div class="paragraph">
<p>一旦您熟悉了标准工具，应该尝试使用Spectator和ng-mocks等替代方案。然后决定是坚持使用隔离的测试助手还是转向更全面的测试库。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/ngneat/spectator">Spectator项目网站</a></p>
</li>
<li>
<p><a href="https://github.com/help-me-mom/ng-mocks">ng-mocks项目网站</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
