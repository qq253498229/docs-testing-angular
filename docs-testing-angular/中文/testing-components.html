<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>组件测试 :: Testing Angular</title>
    <meta name="generator" content="Antora 3.1.14">
    <link rel="stylesheet" href="../../_/css/site.css">
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">Testing Angular</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs-testing-angular" data-version="中文">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="introduction.html">简介</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="target-audience.html">目标受众</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="terminology.html">术语</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-principles.html">测试原则</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="example-applications.html">示例应用程序</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="angular-testing-principles.html">Angular 测试原则</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="test-suites-with-jasmine.html">使用Jasmine编写测试套件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="faking-dependencies.html">伪造依赖</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="debugging-tests.html">调试测试</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="testing-components.html">测试组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components-with-children.html">测试带有子组件的组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components-depending-on-services.html">测试依赖于服务的组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-complex-forms.html">测试复杂表单</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components-with-spectator.html">测试时使用Spectator库简化组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-services.html">测试服务</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-pipes.html">测试管道</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-directives.html">测试指令</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-modules.html">测试模块</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="measuring-code-coverage.html">代码覆盖率测量</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="end-to-end-testing.html">端到端测试</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="summary.html">总结</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index-of-example-applications.html">示例应用程序索引</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="references.html">参考资料</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="acknowledgements.html">鸣谢</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="about.html">关于</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="license.html">许可证</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="other.html">其它</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Testing Angular</span>
    <span class="version">中文</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="start.html">Testing Angular</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="start.html">中文</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="start.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="start.html">Testing Angular</a></li>
    <li><a href="testing-components.html">测试组件</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="目录" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">组件测试</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>学习目标</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 Angular 的测试模块设置组件测试</p>
</li>
<li>
<p>熟悉 Angular 的组件测试抽象</p>
</li>
<li>
<p>访问渲染的 DOM 并检查文本内容</p>
</li>
<li>
<p>模拟用户输入，如点击和表单字段输入</p>
</li>
<li>
<p>测试组件的输入和输出</p>
</li>
<li>
<p>使用辅助函数处理常见的组件测试任务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>组件是 Angular 应用程序的核心。组件组合在一起形成用户界面。</p>
</div>
<div class="paragraph">
<p>组件涉及多个任务，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将模板渲染到 HTML DOM 中。</p>
</li>
<li>
<p>使用输入属性接收来自父组件的数据。</p>
</li>
<li>
<p>使用输出属性向父组件发出数据。</p>
</li>
<li>
<p>通过注册事件处理程序响应用户输入。</p>
</li>
<li>
<p>渲染传递的内容（<code>ng-content</code>）和模板（<code>ng-template</code>）。</p>
</li>
<li>
<p>将数据绑定到表单控件，并允许用户编辑数据。</p>
</li>
<li>
<p>与服务或其他状态管理器进行通信。</p>
</li>
<li>
<p>使用路由信息，如当前 URL 和 URL 参数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有这些任务都需要进行适当的测试。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_计数器组件的单元测试"><a class="anchor" href="#_计数器组件的单元测试"></a>计数器组件的单元测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>作为第一个示例，我们将测试 <a href="https://github.com/9elements/angular-workshop/tree/main/src/app/components/counter">CounterComponent</a> 组件。</p>
</div>
<button class="load-iframe">
See the CounterComponent in action
</button>

<script type="text/x-template">
<p class="responsive-iframe">
<iframe src="https://9elements.github.io/angular-workshop/counter-component" class="responsive-iframe__iframe"></iframe>
</p>
</script>
<div class="paragraph">
<p>在设计组件测试时，指导性的问题是：组件做什么，需要测试什么？如何测试这个行为？</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
计数器的功能
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们将测试 <code>CounterComponent</code> 的以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它显示当前计数。初始值为 0，可以通过输入属性进行设置。</p>
</li>
<li>
<p>当用户激活“+”按钮时，计数增加。</p>
</li>
<li>
<p>当用户激活“-”按钮时，计数减少。</p>
</li>
<li>
<p>当用户在重置输入字段中输入一个数字并激活重置按钮时，计数将设置为给定值。</p>
</li>
<li>
<p>当用户更改计数时，输出属性会发出新的计数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>写下组件的功能已经有助于组织单元测试。上述功能大致对应于测试套件中的规范。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-workshop/tree/main/src/app/components/counter">CounterComponent：完整代码</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testbed"><a class="anchor" href="#_testbed"></a>TestBed</h2>
<div class="sectionbody">
<div class="paragraph">
<p>即使是简单的计数器组件，在 Angular 中渲染组件也需要进行一些准备工作。如果你查看典型 Angular 应用程序的 <a href="https://github.com/9elements/angular-workshop/blob/main/src/main.ts">main.ts</a> 和 <a href="https://github.com/9elements/angular-workshop/blob/main/src/app/app.module.ts">AppModule</a>，你会发现创建了一个“平台”，声明了一个模块，并对该模块进行了初始化。</p>
</div>
<div class="paragraph">
<p>Angular 编译器将模板转换为 JavaScript 代码。为了准备渲染，会创建组件的实例，解析并注入依赖项，然后设置输入属性。</p>
</div>
<div class="paragraph">
<p>最后，将模板渲染到 DOM 中。在测试中，你可以手动完成所有这些操作，但你需要深入了解 Angular 的内部实现。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>TestBed</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>作为替代，Angular 团队提供了 <code>TestBed</code> 来简化单元测试。<code>TestBed</code> 创建并配置了一个 Angular 环境，因此你可以安全且轻松地测试特定的应用程序部分，如组件和服务。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://angular.cn/api/core/testing/TestBed">Angular API 参考文档：TestBed</a></p>
</li>
<li>
<p><a href="https://angular.cn/guide/testing-utility-apis#testbed-class-summary">测试实用工具 API：TestBed</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_配置测试模块"><a class="anchor" href="#_配置测试模块"></a>配置测试模块</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>TestBed</code> 提供了一个测试模块，该模块的配置方式与你应用程序中的普通模块相同：你可以声明组件、指令和管道，提供服务和其他可注入对象，以及导入其他模块。<code>TestBed</code> 有一个静态方法 <code>configureTestingModule</code>，它接受一个模块定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">TestBed.configureTestingModule({
  imports: [ /*… */ ],
  declarations: [ /*… */ ],
  providers: [ /*… */ ],
});</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
声明必要的部分
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在单元测试中，将那些严格必要的部分添加到模块中：被测试的代码、必需的依赖项和伪装对象。例如，当编写 <code>CounterComponent</code> 的单元测试时，我们需要声明该组件类。由于该组件没有依赖项，也没有渲染其他组件、指令或管道，好了我们已经完成了配置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">TestBed.configureTestingModule({
  declarations: [CounterComponent],
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们要测试的组件现在是模块的一部分了。我们准备好渲染它了吗？还没有。首先，我们需要编译所有声明的组件、指令和管道：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">TestBed.compileComponents();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这指示 Angular 编译器将模板文件转换为 JavaScript 代码。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
配置和编译
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>由于 <code>configureTestingModule</code> 返回的仍然是 <code>TestBed</code>，我们可以将这两个调用链接在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">TestBed
  .configureTestingModule({
    declarations: [CounterComponent],
  })
  .compileComponents();</code></pre>
</div>
</div>
<div class="paragraph">
<p>你会在大多数依赖于 <code>TestBed</code> 的 Angular 测试中看到这种模式。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_渲染组件"><a class="anchor" href="#_渲染组件"></a>渲染组件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在，我们有一个完全配置的测试模块，其中包含编译后的组件。最后，我们可以使用 <code>createComponent</code> 渲染要测试的组件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const fixture = TestBed.createComponent(CounterComponent);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>createComponent</code> 返回一个 <code>ComponentFixture</code>，它实质上是围绕组件的一个包装器，提供了有用的测试工具。我们将在后面更详细地了解 <code>ComponentFixture</code>。</p>
</div>
<div class="paragraph">
<p><code>createComponent</code> 将组件渲染到 HTML DOM 中的一个 <code>div</code> 容器元素中。然而，还有一些东西缺失。组件没有完全渲染出来。所有静态的 HTML 存在，但动态的 HTML 却缺失了。模板绑定，如示例中的 <code>{{ count }}</code>，没有被计算。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
手动触发变更检测
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在我们的测试环境中，<strong>没有自动的变更检测</strong>。即使使用默认的变更检测策略，组件在更新时也不会自动渲染和重新渲染。</p>
</div>
<div class="paragraph">
<p>在测试代码中，我们必须 <strong>手动触发变更检测</strong>。这可能有点麻烦，但实际上这是一个特性。它允许我们以同步的方式测试异步行为，这要简单得多。</p>
</div>
<div class="paragraph">
<p>因此，我们需要做的最后一件事就是触发变更检测：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">fixture.detectChanges();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://angular.cn/api/core/testing/ComponentFixture">Angular API 参考文档：ComponentFixture</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testbed_和_jasmine"><a class="anchor" href="#_testbed_和_jasmine"></a>TestBed 和 Jasmine</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用 <code>TestBed</code> 渲染组件的代码现在已经完成。让我们将代码包装在一个 Jasmine 测试套件中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('CounterComponent', () =&gt; {
  let fixture: ComponentFixture&lt;CounterComponent&gt;;

  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      declarations: [CounterComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(CounterComponent);
    fixture.detectChanges();
  });

  it('…', () =&gt; {
    /* … */
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>describe</code>，我们为 <code>CounterComponent</code> 定义了一个测试套件。其中包含一个 <code>beforeEach</code> 块，用于配置 <code>TestBed</code> 并渲染组件。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
异步编译
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可能会想知道为什么传递给 <code>beforeEach</code> 的函数被标记为 <code>异步</code> 函数。这是因为 <code>compileComponents</code> 是一个异步操作。为了编译组件，Angular 需要获取 <code>templateUrl</code> 引用的外部模板文件。</p>
</div>
<div class="paragraph">
<p>如果你使用的是 Angular CLI（很可能是这样），模板文件已经包含在测试捆绑包中，因此它们可以立即使用。如果你没有使用 CLI，那么这些文件必须以异步方式加载。</p>
</div>
<div class="paragraph">
<p>这是一个可能在将来发生变化的实现细节。安全的做法是等待 <code>compileComponents</code> 完成。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>async</code> 和 <code>await</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下，Jasmine 希望你的测试代码是同步的。你传递给 <code>it</code> 的函数以及 <code>beforeEach</code>、<code>beforeAll</code>、<code>afterEach</code>、<code>afterAll</code> 函数需要在一定时间内完成，也就是所谓的超时时间。Jasmine 也支持 <code>异步</code> 的规范。如果你传递一个异步函数，Jasmine 会等待它完成。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="test-suites-with-jasmine.html#_使用jasmine编写测试套件" class="xref page">Jasmine 中的测试套件</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_componentfixture_和_debugelement"><a class="anchor" href="#_componentfixture_和_debugelement"></a>ComponentFixture 和 DebugElement</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>TestBed.createComponent(CounterComponent)</code> 返回一个 fixture，即 <code>ComponentFixture</code> 的实例。fixture 是什么，它提供了什么功能？</p>
</div>
<div class="paragraph">
<p>夹具(fixture) 这个术语来源于对机械部件或电子设备的现实世界测试。一个夹具是一个标准化的框架，用于安装测试对象。夹具持有对象并连接到电子接点，以提供电源以及进行测量。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
ComponentFixture
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在 Angular 的上下文中，<code>ComponentFixture</code> 包含了组件并为组件实例和渲染的 DOM 提供了方便的接口。</p>
</div>
<div class="paragraph">
<p>fixture 通过 <code>componentInstance</code> 属性引用组件实例。在我们的示例中，它包含了一个 <code>CounterComponent</code> 实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const component = fixture.componentInstance;</code></pre>
</div>
</div>
<div class="paragraph">
<p>组件实例主要用于设置输入属性（Inputs）和订阅输出属性（Outputs），例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">// This is a ComponentFixture&lt;CounterComponent&gt;
const component = fixture.componentInstance;
// Set Input
component.startCount = 10;
// Subscribe to Output
component.countChange.subscribe((count) =&gt; {
  /* … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们稍后将更详细地了解如何测试输入属性和输出属性。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>DebugElement</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了访问 DOM 中的元素，Angular 提供了另一个抽象层：<code>DebugElement</code>，它封装了原生的 DOM 元素。fixture 的 <code>debugElement</code> 属性返回组件的宿主元素。对于 <code>CounterComponent</code>，它是 <code>app-counter</code> 元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const { debugElement } = fixture;</code></pre>
</div>
</div>
<div class="paragraph">
<p>DebugElement 提供了一些方便的属性，例如 <code>properties</code>、<code>attributes</code>、<code>classes</code> 和 <code>styles</code>，用于检查 DOM 元素本身。属性 <code>parent</code>、<code>children</code> 和 <code>childNodes</code> 有助于在 DOM 树中进行导航。它们也会返回 <code>DebugElement</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>nativeElement</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通常需要解包 <code>DebugElement</code>，以访问内部的原生 DOM 元素。每个 <code>DebugElement</code> 都有一个 <code>nativeElement</code> 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const { debugElement } = fixture;
const { nativeElement } = debugElement;
console.log(nativeElement.tagName);
console.log(nativeElement.textContent);
console.log(nativeElement.innerHTML);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>nativeElement</code> 的类型为 <code>any</code>，因为 Angular 无法确定包装的 DOM 元素的确切类型。大多数情况下，它是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement"><code>HTMLElement</code></a> 的子类。</p>
</div>
<div class="paragraph">
<p>当使用 <code>nativeElement</code> 时，您需要了解特定元素的 DOM 接口。例如，button 元素在 DOM 中表示为 <a href="https://developer.mozilla.org/en-US/docs/Web/API/"><code>HTMLButtonElement</code></a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://angular.cn/api/core/testing/ComponentFixture">Angular API 参考文档: ComponentFixture</a></p>
</li>
<li>
<p><a href="https://angular.cn/api/core/DebugElement">Angular API 参考文档: DebugElement</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_编写第一个组件规范"><a class="anchor" href="#_编写第一个组件规范"></a>编写第一个组件规范</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们已经编译了一个测试套件，用于渲染 <code>CounterComponent</code>。我们已经了解了 Angular 的主要测试抽象: <code>TestBed</code>、<code>ComponentFixture</code> 和 <code>DebugElement</code>。</p>
</div>
<div class="paragraph">
<p>现在让我们开始撸起袖子，编写第一个规范！我们的小计数器的主要功能是能够递增计数。因此，我们的规范如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('increments the count', () =&gt; {
  /* … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>安排（Arrange）、行动（Act）和断言（Assert）</strong> 阶段有助于规范我们的规范：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们已经在 <code>beforeEach</code> 块中涵盖了 <em>安排(Arrange)</em> 阶段，该阶段渲染了组件。</p>
</li>
<li>
<p>在 <em>行动(Act)</em> 阶段，我们点击增加按钮。</p>
</li>
<li>
<p>在 <em>断言(Assert)</em> 阶段，我们检查显示的计数是否已增加。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('increments the count', () =&gt; {
  // Act: Click on the increment button
  // Assert: Expect that the displayed count now reads “1”.
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>要点击增加按钮，需要进行两个操作：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在 DOM 中找到增加按钮元素。</p>
</li>
<li>
<p>触发点击事件。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>让我们首先学习如何在 DOM 中查找元素。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用测试_id_查询_dom"><a class="anchor" href="#_使用测试_id_查询_dom"></a>使用测试 ID 查询 DOM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>每个 <code>DebugElement</code> 都提供了 <code>query</code> 和 <code>queryAll</code> 方法来查找后代元素（子元素、孙子元素等）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>query</code> and <code>queryAll</code>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><code>query</code> 方法返回满足条件的第一个后代元素。</p>
</li>
<li>
<p><code>queryAll</code> 方法返回所有匹配的元素数组。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这两个方法都需要一个谓词函数，该函数用于判断每个元素并返回 <code>true</code> 或 <code>false</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>By.css</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Angular 提供了预定义的谓词函数，可以使用熟悉的 CSS 选择器来查询 DOM。为此，将带有 CSS 选择器的 <code>By.css('…')</code> 传递给 <code>query</code> 和 <code>queryAll</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const { debugElement } = fixture;
// Find the first h1 element
const h1 = debugElement.query(By.css('h1'));
// Find all elements with the class .user
const userElements = debugElement.queryAll(By.css('.user'));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>query</code> 方法的返回值是一个 <code>DebugElement</code>，而 <code>queryAll</code> 的返回值是一个 <code>DebugElement</code> 数组（<code>DebugElement[]</code> 在 TypeScript 中的表示方式）。</p>
</div>
<div class="paragraph">
<p>在上面的示例中，我们使用了类型选择器（<code>h1</code>）和类选择器（<code>.user</code>）来查找 DOM 中的元素。对于熟悉 CSS 的人来说，这是非常熟悉的。</p>
</div>
<div class="paragraph">
<p>虽然这些选择器在样式化组件时很好用，但在测试中使用它们需要考虑一下。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
避免紧密耦合
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>类型和类选择器在测试和模板之间引入了 <em>紧密耦合</em>。HTML 元素是根据语义原因选择的。类通常是为了样式化选择的。当组件模板进行重构时，这些都经常发生变化。如果元素类型或类发生变化，测试应该失败吗？</p>
</div>
<div class="paragraph">
<p>有时候，元素类型和类对于正在测试的功能至关重要。但大多数情况下，它们与功能无关。测试应该通过一个永远不会改变且不带有其他含义的特征来找到元素：测试 ID。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
测试 ID
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>测试 ID</strong> 是专门为了在测试中查找元素而赋予元素的标识符。如果元素类型或其他属性发生变化，测试仍然能够找到该元素。</p>
</div>
<div class="paragraph">
<p>标记 HTML 元素的首选方式是使用 <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes">data 属性</a>。与元素类型、<code>class</code> 或 <code>id</code> 属性不同，数据属性没有任何预定义的含义。数据属性永远不会互相冲突。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>data-testid</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在本指南中，我们使用 <strong><code>data-testid</code></strong> 属性来标记元素。例如，我们可以使用 <code>data-testid="increment-button"</code> 来标记 <code>CounterComponent</code> 中的增加按钮：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;button (click)="increment()" data-testid="increment-button"&gt;+&lt;/button&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在测试中，我们使用相应的属性选择器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const incrementButton = debugElement.query(
  By.css('[data-testid="increment-button"]')
);</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
建立一个约定
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>关于在测试中查找元素的最佳方法有很多细微的讨论。当然，有几种有效且复杂的方法。本指南只提供一种可能的简单和可行的方法。</p>
</div>
<div class="paragraph">
<p>在DOM查询方面，Angular测试工具是中立的。它们可以容忍不同的方法。经过考虑后，您应该选择一种具体的解决方案，将其作为 <a href="angular-testing-principles.html#<em>测试约定</em>" class="xref page">测试约定</a> 记录下来，并在所有测试中一致应用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://angular.cn/api/platform-browser/By">Angular API参考文档：By.css</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_触发事件处理程序"><a class="anchor" href="#_触发事件处理程序"></a>触发事件处理程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在，我们已经标记并获取了增加按钮，我们需要点击它。</p>
</div>
<div class="paragraph">
<p>在测试中模拟用户输入，如点击、输入文本、移动指针和按键，是一个常见的任务。从Angular的角度来看，用户输入会导致DOM事件。</p>
</div>
<div class="paragraph">
<p>组件模板使用模式 <code>(event)="handler($event)"</code> 注册事件处理程序。在测试中，我们需要模拟事件以调用这些处理程序。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
触发事件处理程序
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>DebugElement</code> 有一个非常有用的方法用于触发事件：<code>triggerEventHandler</code>。该方法调用给定事件类型（例如 <code>click</code>）的所有事件处理程序。作为第二个参数，它期望一个伪事件对象，该对象将传递给处理程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">incrementButton.triggerEventHandler('click', {
  /* … Event properties … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个示例在增加按钮上触发了一个 <code>click</code> 事件。由于模板包含了 <code>(click)="increment()"</code>，<code>CounterComponent</code> 的 <code>increment</code> 方法将被调用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
事件对象
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>increment</code> 方法并没有使用事件对象。调用的是简单的 <code>increment()</code>，而不是 <code>increment($event)</code>。因此，我们不需要传递一个伪造的事件对象，可以直接传递 <code>null</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">incrementButton.triggerEventHandler('click', null);</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，<code>triggerEventHandler</code> 不会触发合成的DOM事件。它的影响仅限于 <code>DebugElement</code> 的抽象层级，不会触及原生的DOM。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
没有事件冒泡
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>只要事件处理程序在元素上注册了，就可以这样做。如果事件处理程序注册在父元素上，并依赖于事件冒泡，你就需要直接在该父元素上调用 <code>triggerEventHandler</code>。<code>triggerEventHandler</code> 不会模拟事件冒泡或任何其他真实事件可能具有的效果。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_期望文本输出"><a class="anchor" href="#_期望文本输出"></a>期望文本输出</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们已经完成了 <em>Act</em> 阶段，在该阶段测试会点击增加按钮。在 <em>Assert</em> 阶段，我们需要期望显示的计数从“0”变为“1”。</p>
</div>
<div class="paragraph">
<p>在模板中，计数被渲染到一个 <code>strong</code> 元素中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;strong&gt;{{ count }}&lt;/strong&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
通过测试id查找元素
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在我们的测试中，我们需要找到这个元素并读取它的文本内容。为此，我们添加一个测试id：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;strong data-testid="count"&gt;{{ count }}&lt;/strong&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以像往常一样找到该元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const countOutput = debugElement.query(
  By.css('[data-testid="count"]')
);</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
文本内容
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>接下来的步骤是读取元素的内容。在DOM中，计数是 <code>strong</code> 的子节点，它是一个文本节点。</p>
</div>
<div class="paragraph">
<p>不幸的是，<code>DebugElement</code> 没有用于读取文本内容的方法或属性。我们需要访问具有方便的 <code>textContent</code> 属性的原生DOM元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">countOutput.nativeElement.textContent</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，我们使用Jasmine的 <code>expect</code> 来断言这个字符串是否为 <code>"1"</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">expect(countOutput.nativeElement.textContent).toBe('1');</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>counter.component.spec.ts</code> 现在如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">/* Incomplete! */
describe('CounterComponent', () =&gt; {
  let fixture: ComponentFixture&lt;CounterComponent&gt;;
  let debugElement: DebugElement;

  // Arrange
  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      declarations: [CounterComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(CounterComponent);
    fixture.detectChanges();
    debugElement = fixture.debugElement;
  });

  it('increments the count', () =&gt; {
    // Act
    const incrementButton = debugElement.query(
      By.css('[data-testid="increment-button"]')
    );
    incrementButton.triggerEventHandler('click', null);

    // Assert
    const countOutput = debugElement.query(
      By.css('[data-testid="count"]')
    );
    expect(countOutput.nativeElement.textContent).toBe('1');
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们运行该测试套件时，该规范将失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">CounterComponent increments the count FAILED
  Error: Expected '0' to be '1'.</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里出了什么问题？是实现有问题吗？不，测试只是漏掉了一些重要的内容。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
手动进行变更检测
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们已经提到在测试环境中，Angular不会自动检测变更以更新DOM。点击增加按钮会更改组件实例的 <code>count</code> 属性。要更新模板绑定 <code>{{ count }}</code>，我们需要 <em>手动触发变更检测</em>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">fixture.detectChanges();</code></pre>
</div>
</div>
<div class="paragraph">
<p>完整的测试套件现在如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('CounterComponent', () =&gt; {
  let fixture: ComponentFixture&lt;CounterComponent&gt;;
  let debugElement: DebugElement;

  // Arrange
  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      declarations: [CounterComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(CounterComponent);
    fixture.detectChanges();
    debugElement = fixture.debugElement;
  });

  it('increments the count', () =&gt; {
    // Act
    const incrementButton = debugElement.query(
      By.css('[data-testid="increment-button"]')
    );
    incrementButton.triggerEventHandler('click', null);
    // Re-render the Component
    fixture.detectChanges();

    // Assert
    const countOutput = debugElement.query(
      By.css('[data-testid="count"]')
    );
    expect(countOutput.nativeElement.textContent).toBe('1');
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>恭喜！我们已经编写了我们的第一个组件测试。虽然它还不完整，但已经包含了一个典型的工作流程。随着我们添加每个规范，我们将对现有代码进行小的改进。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-workshop/blob/main/src/app/components/counter/counter.component.spec.ts">CounterComponent: 测试代码</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_测试辅助函数"><a class="anchor" href="#_测试辅助函数"></a>测试辅助函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们需要测试的下一个 <code>CounterComponent</code> 功能是递减按钮。它与递增按钮非常相似，所以规范几乎相同。</p>
</div>
<div class="paragraph">
<p>首先，我们给递减按钮添加一个测试ID：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;button (click)="decrement()" data-testid="decrement-button"&gt;-&lt;/button&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们编写规范：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('decrements the count', () =&gt; {
  // Act
  const decrementButton = debugElement.query(
    By.css('[data-testid="decrement-button"]')
  );
  decrementButton.triggerEventHandler('click', null);
  // Re-render the Component
  fixture.detectChanges();

  // Assert
  const countOutput = debugElement.query(
    By.css('[data-testid="count"]')
  );
  expect(countOutput.nativeElement.textContent).toBe('-1');
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们会发现，这个规范没有新内容，只不过是测试标识、变量名和预期输出发生了变化。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
重复的模式
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在我们有两个几乎完全相同的规范，代码的重复度很高，信噪比(signal-to-noise ratio)很低，也就是说很多代码只起到了很少的作用。让我们识别出这里重复的模式：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过测试标识查找元素</p>
</li>
<li>
<p>点击通过测试标识找到的元素</p>
</li>
<li>
<p>在通过测试标识找到的元素上期望给定的文本内容</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这些任务是非常通用的，几乎会出现在每个组件规范中。所以就值得为它们编写一个测试助手。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
测试助手
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>测试助手</strong> 是简化测试代码的工具。它使测试代码更简洁、更有意义。由于规范应该描述实现，因此可读性强的规范要比晦涩难懂的规范更好。</p>
</div>
<div class="paragraph">
<p>您的测试助手应将 <a href="angular-testing-principles.html#_测试约定" class="xref page">测试约定</a> 转化为代码。它们不仅改善了单个测试，还确保所有测试使用相同的模式并且同样正常工作。</p>
</div>
<div class="paragraph">
<p>测试助手可以是一个简单的函数，也可以是一个抽象类或Jasmine扩展。首先，我们将常见任务提取为普通函数。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
通过测试标识查找
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>首先，让我们编写一个通过测试标识查找元素的辅助函数。我们已经多次使用了这个模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const xyzElement = fixture.debugElement.query(
  By.css('[data-testid="xyz"]')
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将这段代码转移到可重用的函数中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">function findEl&lt;T&gt;(
  fixture: ComponentFixture&lt;T&gt;,
  testId: string
): DebugElement {
  return fixture.debugElement.query(
    By.css(`[data-testid="${testId}"]`)
  );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个函数是自包含的。我们需要显式地传递组件的 fixture。由于 <code>ComponentFixture&lt;T&gt;</code> 需要一个类型参数 - 包装的组件类型 -，<code>findEl</code> 也有一个名为 <code>T</code> 的类型参数。当你传递一个 <code>ComponentFixture</code> 时，TypeScript 会自动推断出组件的类型。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
点击
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>其次，我们编写一个测试助手，它可以点击具有给定测试 id 的元素。这个助手基于 <code>findEl</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">export function click&lt;T&gt;(
  fixture: ComponentFixture&lt;T&gt;,
  testId: string
): void {
  const element = findEl(fixture, testId);
  const event = makeClickEvent(element.nativeElement);
  element.triggerEventHandler('click', event);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了创建一个模拟的点击事件对象，<code>click</code> 函数调用另一个函数 <code>makeClickEvent</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">export function makeClickEvent(
  target: EventTarget
): Partial&lt;MouseEvent&gt; {
  return {
    preventDefault(): void {},
    stopPropagation(): void {},
    stopImmediatePropagation(): void {},
    type: 'click',
    target,
    currentTarget: target,
    bubbles: true,
    cancelable: true,
    button: 0
  };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个函数返回一个部分的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent">MouseEvent</a> 模拟对象，其中包含真实点击事件的最重要的方法和属性。它适用于在指针位置和修饰键不重要的情况下点击按钮和链接。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
点击意味着激活(activate)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>点击(click)</code> 测试助手可用于每个具有 <code>(click)="…"</code> 事件处理程序的元素。为了辅助功能，请确保元素可以聚焦(focussed)和激活(activated)。对于按钮（<code>button</code> 元素）和链接（<code>a</code> 元素）来说，这已经是默认情况。</p>
</div>
<div class="paragraph">
<p>从历史上看，<code>点击(click)</code> 事件只由鼠标输入触发。但是现在，它是一个通用的“激活(activate)”事件。它还可以由触摸输入（“轻触(tap)”）、键盘输入或语音输入触发。</p>
</div>
<div class="paragraph">
<p>因此，在组件中，您不需要单独监听触摸或键盘事件。在测试中，通常只需要一个通用的 <code>点击</code> 事件即可。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
期望文本内容
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>第三个测试助手是一个函数，用于在具有给定测试 id 的元素上期望给定的文本内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">export function expectText&lt;T&gt;(
  fixture: ComponentFixture&lt;T&gt;,
  testId: string,
  text: string,
): void {
  const element = findEl(fixture, testId);
  const actualText = element.nativeElement.textContent;
  expect(actualText).toBe(text);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次强调，这是一个简单的实现，我们将在以后进行改进。</p>
</div>
<div class="paragraph">
<p>使用这些助手函数，我们重新编写我们的规范（spec）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('decrements the count', () =&gt; {
  // Act
  click(fixture, 'decrement-button');
  // Re-render the Component
  fixture.detectChanges();

  // Assert
  expectText(fixture, 'count', '-1');
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样的代码读起来更清晰，写起来也更简洁！一眼就能看出规范在做什么。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-workshop/blob/main/src/app/components/counter/counter.component.spec.ts">CounterComponent: test code</a></p>
</li>
<li>
<p><a href="https://github.com/9elements/angular-workshop/blob/main/src/app/spec-helpers/element.spec-helper.ts">Element spec helpers: full code</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_填充表单"><a class="anchor" href="#_填充表单"></a>填充表单</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们已经成功测试了增加和减少按钮。我们还需要测试的剩下的用户界面功能是重置功能。</p>
</div>
<div class="paragraph">
<p>在用户界面中，有一个重置输入字段和一个重置按钮。用户在字段中输入一个新数字，然后点击按钮。组件将计数重置为用户提供的数字。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
设置字段值
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们已经知道如何点击按钮，但是如何填写表单字段呢？不幸的是，Angular 的测试工具没有提供一种简单地填写表单的解决方案。</p>
</div>
<div class="paragraph">
<p>答案取决于字段类型和值。一般的答案是：找到原生 DOM 元素，并将 <code>value</code> 属性设置为新值。</p>
</div>
<div class="paragraph">
<p>对于重置输入字段来说，这意味着：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const resetInput = debugElement.query(
  By.css('[data-testid="reset-input"]')
);
resetInput.nativeElement.value = '123';</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用我们的测试助手：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const resetInputEl = findEl(fixture, 'reset-input').nativeElement;
resetInputEl.value = '123';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样可以通过编程的方式对值进行填充。</p>
</div>
<div class="paragraph">
<p>在 <code>CounterComponent</code> 的模板中，重置输入字段有一个 <em>模板引用变量</em>，<code>#resetInput</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;input type="number" #resetInput data-testid="reset-input" /&gt;
&lt;button (click)="reset(resetInput.value)" data-testid="reset-button"&gt;
  Reset
&lt;/button&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>点击处理程序使用 <code>resetInput</code> 来访问 <code>input</code> 元素，读取其 <code>值</code> 并将其传递给 <code>reset</code> 方法。</p>
</div>
<div class="paragraph">
<p>这个示例已经可以工作，因为表单非常简单。设置字段的 <code>值</code> 并不能完全模拟用户输入，并且还不能与模板驱动或响应式表单一起使用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
伪造 <code>输入</code> 事件
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Angular 表单不能直接观察到 <code>值</code> 的变化。相反，Angular 监听浏览器在字段值变化时触发的 <code>input</code> 事件。</p>
</div>
<div class="paragraph">
<p>为了 <strong>兼容模板驱动和响应式表单</strong>，我们需要触发一个伪造的 <code>input</code> 事件。这样的事件也被称为 <em>合成事件</em>。</p>
</div>
<div class="paragraph">
<p>在较新的浏览器中，我们可以使用 <code>new Event('input')</code> 来创建一个伪造的 <code>input</code> 事件。要触发事件，我们使用目标元素的 <code>dispatchEvent</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const resetInputEl = findEl(fixture, 'reset-input').nativeElement;
resetInputEl.value = '123';
resetInputEl.dispatchEvent(new Event('input'));</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要在旧版的 Internet Explorer 中运行测试，需要更多的代码。Internet Explorer 不支持 <code>new Event('…')</code>，而是使用 <code>document.createEvent</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const event = document.createEvent('Event');
event.initEvent('input', true, false);
resetInputEl.dispatchEvent(event);</code></pre>
</div>
</div>
<div class="paragraph">
<p>重置功能的完整规范如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('resets the count', () =&gt; {
  const newCount = '123';

  // Act
  const resetInputEl = findEl(fixture, 'reset-input').nativeElement;
  // Set field value
  resetInputEl.value = newCount;
  // Dispatch input event
  const event = document.createEvent('Event');
  event.initEvent('input', true, false);
  resetInputEl.dispatchEvent(event);

  // Click on reset button
  click(fixture, 'reset-button');
  // Re-render the Component
  fixture.detectChanges();

  // Assert
  expectText(fixture, 'count', newCount);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>填写表单是测试中常见的任务，因此将代码提取出来放入助手函数中是有意义的。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
辅助函数
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>辅助函数 <code>setFieldValue</code> 接受一个组件 fixture、一个测试 id 和一个字符串值。它使用 <code>findEl</code> 找到相应的元素。使用另一个辅助函数 <code>setFieldElementValue</code>，它设置 <code>值</code> 并触发一个输入事件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">export function setFieldValue&lt;T&gt;(
  fixture: ComponentFixture&lt;T&gt;,
  testId: string,
  value: string,
): void {
  setFieldElementValue(
    findEl(fixture, testId).nativeElement,
    value
  );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在 <a href="https://github.com/9elements/angular-workshop/blob/main/src/app/spec-helpers/element.spec-helper.ts">element.spec-helper.ts</a> 文件中找到所涉及的辅助函数的完整源代码。</p>
</div>
<div class="paragraph">
<p>使用新创建的 <code>setFieldValue</code> 辅助函数，我们可以简化规范（spec）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('resets the count', () =&gt; {
  const newCount = '123';

  // Act
  setFieldValue(fixture, 'reset-input', newCount);
  click(fixture, 'reset-button');
  fixture.detectChanges();

  // Assert
  expectText(fixture, 'count', newCount);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管重置功能很简单，但这是如何测试大多数表单逻辑的方式。稍后，我们将学习如何 <a href="testing-complex-forms.html#_测试复杂表单" class="xref page">测试复杂的表单</a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
无效输入
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>CounterComponent</code> 在重置计数之前会检查输入值。如果值不是数字，点击重置按钮将不会有任何操作。</p>
</div>
<div class="paragraph">
<p>我们需要用另一个规范来覆盖这种行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('does not reset if the value is not a number', () =&gt; {
  const value = 'not a number';

  // Act
  setFieldValue(fixture, 'reset-input', value);
  click(fixture, 'reset-button');
  fixture.detectChanges();

  // Assert
  expectText(fixture, 'count', startCount);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个规范中的小差异是，我们将字段值设置为“not a number”，这是一个无法解析为数字的字符串，并期望计数保持不变。</p>
</div>
<div class="paragraph">
<p>就是这样！我们已经分别使用有效和无效的输入值，对重置表单功能进行了测试。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-workshop/blob/main/src/app/components/counter/counter.component.spec.ts">CounterComponent: test code</a></p>
</li>
<li>
<p><a href="https://github.com/9elements/angular-workshop/blob/main/src/app/spec-helpers/element.spec-helper.ts">Element spec helpers: full code</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_测试输入"><a class="anchor" href="#_测试输入"></a>测试输入</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>CounterComponent</code> 有一个 <code>@Input()</code>: <code>startCount</code> ，用于设置初始count值。我们需要测试计数器如何正确处理这个 <code>@Input()</code>。</p>
</div>
<div class="paragraph">
<p>例如，如果我们将 <code>startCount</code> 设置为 <code>123</code>，渲染的count也应该是 <code>123</code>。如果输入为空，渲染的count则应该是 <code>0</code>，即默认值。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
设置 <code>@Input()</code> 值
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Input()</code> 是组件实例的特殊属性。我们可以在 <em>Arrange</em> 阶段设置这个属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const component = fixture.componentInstance;
component.startCount = 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在组件中最好不要改变 <code>@Input()</code> 的值。<code>@Input()</code> 属性应始终反映父组件传入的数据。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>@Input()</code> 与组件状态
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这就是为什么 <code>CounterComponent</code> 既有一个名为 <code>startCount</code> 的公共 <code>@Input()</code>，又有一个名为 <code>count</code> 的内部属性。当用户点击增加或减少按钮时，<code>count</code> 会发生变化，但 <code>startCount</code> 保持不变。</p>
</div>
<div class="paragraph">
<p>每当 <code>startCount</code> <code>@Input()</code> 发生变化时，<code>count</code> 需要被设置为 <code>startCount</code> 的值。最安全的做法是在 <code>ngOnChanges</code> 生命周期方法中进行设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">public ngOnChanges(): void {
  this.count = this.startCount;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ngOnChanges</code> 在“数据绑定属性”发生变化时被调用，包括 Inputs。</p>
</div>
<div class="paragraph">
<p>让我们为 <code>startCount</code> <code>@Input()</code> 编写一个测试。我们在 <code>beforeEach</code> 块中设置 <code>@Input()</code>，在调用 <code>detectChanges</code> 之前。规范本身检查正确的计数是否被渲染出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">/* Incomplete! */
beforeEach(async () =&gt; {
  /* … */

  // Set the Input
  component.startCount = startCount;
  fixture.detectChanges();
});

it('shows the start count', () =&gt; {
  expectText(fixture, 'count', String(count));
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们运行这个规范时，我们发现它失败了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">CounterComponent &gt; shows the start count
  Expected '0' to be '123'.</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>ngOnChanges</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这里出了什么问题？我们是不是再次忘记了调用 <code>detectChanges</code> ？不是的，我们忘记了调用 <code>ngOnChanges</code>！</p>
</div>
<div class="paragraph">
<p>在测试环境中，<code>ngOnChanges</code> 不会自动调用。我们必须在设置完 <code>@Input()</code> 后手动调用它。</p>
</div>
<div class="paragraph">
<p>以下是修正后的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('CounterComponent', () =&gt; {
  let component: CounterComponent;
  let fixture: ComponentFixture&lt;CounterComponent&gt;;

  const startCount = 123;

  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      declarations: [CounterComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(CounterComponent);
    component = fixture.componentInstance;
    component.startCount = startCount;
    // Call ngOnChanges, then re-render
    component.ngOnChanges();
    fixture.detectChanges();
  });

  /* … */

  it('shows the start count', () =&gt; {
    expectText(fixture, 'count', String(startCount));
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>CounterComponent</code> 期望一个 <code>number</code> 输入，并将其渲染到 DOM 中。当从 DOM 中读取文本时，我们处理的却总是字符串。这就是为什么我们传入一个数字 <code>123</code>，但期望找到字符串 <code>'123'</code> 的原因。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-workshop/blob/main/src/app/components/counter/counter.component.spec.ts">CounterComponent: test code</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_测试输出"><a class="anchor" href="#_测试输出"></a>测试输出</h2>
<div class="sectionbody">
<div class="paragraph">
<p>输入(<code>@Input()</code>)将数据从父组件传递到子组件，输出(<code>@Output()</code>)将数据从子组件发送到父组件。结合起来，一个组件可以只使用所需的数据执行特定的操作。</p>
</div>
<div class="paragraph">
<p>例如，一个组件可以呈现一个表单，以便用户可以编辑或审查数据。一旦完成，组件就会将数据作为输出发出。</p>
</div>
<div class="paragraph">
<p>输出不是一个面向用户的功能，但是它是公共组件 API 的重要组成部分。从技术上讲，输出是组件实例的属性。单元测试必须仔细检查输出，以证明组件与其他组件的协作良好。</p>
</div>
<div class="paragraph">
<p><code>CounterComponent</code> 有一个名为 <code>countChange</code> 的输出。每当计数发生变化时，<code>countChange</code> 输出会发出新的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">export class CounterComponent implements OnChanges {
  /* … */
  @Output()
  public countChange = new EventEmitter&lt;number&gt;();
  /* … */
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
订阅 Observable
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>EventEmitter</code> 是 RxJS <code>Subject</code> 的子类，它本身扩展了 RxJS <code>Observable</code>。组件使用 <code>emit</code> 方法来发布新的值，而父组件使用 <code>subscribe</code> 方法来监听发布的值。在测试环境中，我们也将进行相同的操作。</p>
</div>
<div class="paragraph">
<p>让我们为 <code>countChange</code> 输出编写一个规范！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('emits countChange events on increment', () =&gt; {
  /* … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在规范中，我们通过 <code>fixture.componentInstance.countChange</code> 访问 Output。在 <em>Arrange</em> 阶段，我们订阅 <code>EventEmitter</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('emits countChange events on increment', () =&gt; {
  // Arrange
  component.countChange.subscribe((count) =&gt; {
    /* … */
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们需要验证当点击递增按钮时，观察者函数是否以正确的值被调用。在 <em>Act</em> 阶段，我们使用我们的辅助函数点击按钮：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('emits countChange events on increment', () =&gt; {
  // Arrange
  component.countChange.subscribe((count) =&gt; {
    /* … */
  });

  // Act
  click(fixture, 'increment-button');
});</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
修改变量值
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在 <em>Assert</em> 阶段，我们期望 <code>count</code> 具有正确的值。最简单的方法是在 spec 的作用域中声明一个变量。让我们将其命名为 <code>actualCount</code>。最初，它的值是 <code>未定义(undefined)</code> 的。观察者函数设置一个值 - 或者如果它从未被调用，则不设置任何值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('emits countChange events on increment', () =&gt; {
  // Arrange
  let actualCount: number | undefined;
  component.countChange.subscribe((count: number) =&gt; {
    actualCount = count;
  });

  // Act
  click(fixture, 'increment-button');

  // Assert
  expect(actualCount).toBe(1);
});</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
期望值发生变化
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>点击按钮会同步地发出 count 并调用观察者函数。这就是为什么代码的下一行可以期望 <code>actualCount</code> 已经发生了变化。</p>
</div>
<div class="paragraph">
<p>你可能想知道为什么我们没有将 <code>expect</code> 调用放在观察者函数中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">/* Not recommended! */
it('emits countChange events on increment', () =&gt; {
  // Arrange
  component.countChange.subscribe((count: number) =&gt; {
    // Assert
    expect(count).toBe(1);
  });

  // Act
  click(fixture, 'increment-button');
});</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
始终执行断言
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这种方法也是可行的。但是想象一下，如果被测试的功能出现故障，输出发不出来，那么 <code>expect</code> 就不会被调用了。</p>
</div>
<div class="paragraph">
<p>默认情况下，Jasmine 会警告您该规范没有期望值，但将该规范视为成功（参见 <a href="angular-testing-principles.html#_配置karma和jasmine" class="xref page">配置 Karma 和 Jasmine</a>）。在这种情况下，我们希望该规范的失败结果明确地显示出来，以确保期望值始终能被执行。</p>
</div>
<div class="paragraph">
<p>现在，我们已经验证了在点击增加按钮时 <code>countChange</code> 是否发出。我们还需要证明输出在减少和重置时也会发出。我们可以通过添加两个更多的规范来实现，这两个规范与现有规范相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('emits countChange events on decrement', () =&gt; {
  // Arrange
  let actualCount: number | undefined;
  component.countChange.subscribe((count: number) =&gt; {
    actualCount = count;
  });

  // Act
  click(fixture, 'decrement-button');

  // Assert
  expect(actualCount).toBe(-1);
});

it('emits countChange events on reset', () =&gt; {
  const newCount = '123';

  // Arrange
  let actualCount: number | undefined;
  component.countChange.subscribe((count: number) =&gt; {
    actualCount = count;
  });

  // Act
  setFieldValue(fixture, 'reset-input', newCount);
  click(fixture, 'reset-button');

  // Assert
  expect(actualCount).toBe(newCount);
});</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-workshop/blob/main/src/app/components/counter/counter.component.spec.ts">CounterComponent: test code</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_重复的组件规范"><a class="anchor" href="#_重复的组件规范"></a>重复的组件规范</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用三个规范测试 <code>countChange</code> ，这样的输出效果很好，但代码重复度却很高。测试辅助函数虽然可以进一步减少重复代码的，但是关于重复的测试代码是否成问题，是否真的有必要减少这些重复，专家们有不同的意见。</p>
</div>
<div class="paragraph">
<p>一方面，很难抓住重复规范的核心(共同点)。测试辅助函数形成了一种自定义语言，可以清晰而简洁地表达测试指令。例如，如果您的规范通过测试 ID 查找 DOM 元素，测试辅助函数会建立约定并隐藏实现细节。</p>
</div>
<div class="paragraph">
<p>另一方面，像辅助函数这样的抽象会使测试变得更复杂，因此会更难理解。阅读规范的开发人员首先需要熟悉测试辅助函数的逻辑。毕竟，测试应该比实现代码更易读才对。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
重复与抽象
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在软件开发中，有关重复和抽象价值的问题存在争议。 <a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">正如 Sandi Metz 所说</a>，“重复比错误的抽象要好得多”。</p>
</div>
<div class="paragraph">
<p>当编写规范时，这一点尤为正确。您应该尝试使用 <code>beforeEach</code>/<code>beforeAll</code>、更简单的辅助函数甚至是测试库来消除重复代码和样板代码。但是不要试图将您在业务实现代码上的优化习惯和技巧应用在测试代码上。</p>
</div>
<div class="paragraph">
<p>测试应该重现所有相关的逻辑情况。为这些不同的、有时甚至是互斥的情况提取出合适的抽象，通常没什么用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
谨慎地减少重复
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于这个问题，您的实践可能会有所不同。为了完整起见，让我们讨论一下如何减少 <code>countChange</code> 输出规范中的重复。</p>
</div>
<div class="paragraph">
<p><code>@Output()</code> 是一个 <code>EventEmitter</code>，它是一个有完全功能的 RxJS <code>Observable</code>。这使得我们可以按照自己的方式转换 <code>Observable</code>。具体来说，我们可以点击所有三个按钮，然后期望 <code>countChange</code> 输出已发出三个值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">it('emits countChange events', () =&gt; {
  // Arrange
  const newCount = 123;

  // Capture all emitted values in an array
  let actualCounts: number[] | undefined;

  // Transform the Observable, then subscribe
  component.countChange.pipe(
    // Close the Observable after three values
    take(3),
    // Collect all values in an array
    toArray()
  ).subscribe((counts) =&gt; {
    actualCounts = counts;
  });

  // Act
  click(fixture, 'increment-button');
  click(fixture, 'decrement-button');
  setFieldValue(fixture, 'reset-input', String(newCount));
  click(fixture, 'reset-button');

  // Assert
  expect(actualCounts).toEqual([1, 0, newCount]);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个示例需要一些 RxJS 知识。在测试 Angular 应用程序时，我们会一遍又一遍地遇到 RxJS Observable。如果您不理解上面的示例，完全没有关系。这只是一种将三个规范合并为一个的可选方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-workshop/blob/main/src/app/components/counter/counter.component.spec.ts">CounterComponent: 测试代码</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_组件测试黑盒_vs_白盒"><a class="anchor" href="#_组件测试黑盒_vs_白盒"></a>组件测试黑盒 vs. 白盒</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果组件测试的模拟能够与用户和组件的交互更相似，那么这些测试就是最有意义的。我们编写的测试符合这个原则。我们直接使用 DOM 来读取文本、点击按钮和填写表单字段，因为这就是用户所做的操作。</p>
</div>
<div class="paragraph">
<p>这些测试是黑盒测试。我们已经在理论上讨论了 <a href="testing-principles.html#_黑盒测试与白盒测试" class="xref page">黑盒与白盒测试</a>。两者都是有效的测试方法。正如先前所述，本指南首先建议使用黑盒测试。</p>
</div>
<div class="paragraph">
<p>强制进行黑盒测试的一种常见技术是将内部方法标记为 <code>private</code> ，以便在测试中无法调用这些方法。测试应该只检查文档化的公共 API。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
内部但仍然是 <code>public</code> 的
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在 Angular 组件中，外部和内部属性和方法的区别与它们在 TypeScript 中的可见性（<code>public</code> vs. <code>private</code>）不一致。属性和方法需要是 <code>public</code> 的，以便模板能够访问它们。</p>
</div>
<div class="paragraph">
<p>这对于 Input 和 Output 属性是有意义的。它们需要从外部（即您的测试）进行读取和写入。然而，还存在一些仅对模板 <code>public</code> 的内部属性和方法。</p>
</div>
<div class="paragraph">
<p>例如，<code>CounterComponent</code> 具有一个名为 <code>startCount</code> 的 Input 和一个名为 <code>countChange</code> 的 Output。它们都是 <code>public</code> 的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">@Input()
public startCount = 0;

@Output()
public countChange = new EventEmitter&lt;number&gt;();</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们构成了公共 API。然而，还有几个其他的属性和方法是 <code>public</code> 的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">public count = 0;
public increment(): void { /* … */ }
public decrement(): void { /* … */ }
public reset(newCount: string): void { /* … */ }</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
对于模板而言是 <code>public</code> 的
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这些属性和方法是内部的，仅在组件内部使用。然而，它们需要是 <code>public</code> 的，以便模板可以访问它们。Angular将模板编译为TypeScript代码，而TypeScript确保模板代码只能访问公共属性和方法。</p>
</div>
<div class="paragraph">
<p>在我们的 <code>CounterComponent</code> 黑盒测试中，我们通过点击“+”按钮来增加计数。相比之下，许多 Angular 测试教程进行组件的白盒测试。它们直接调用 <code>increment</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">/* Not recommended! */
describe('CounterComponent', () =&gt; {
  /* … */
  it('increments the count', () =&gt; {
    component.increment();
    fixture.detectChanged();
    expectText(fixture, 'count', '1');
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个白盒测试通过调用内部但是 <code>public</code> 的方法来访问组件。有时候这样做是有价值的，但大部分情况下是被滥用的。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
输入、输出和 DOM
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>正如我们所学到的，组件测试在与组件通过输入、输出和呈现的 DOM 进行交互时才具有意义。如果组件测试调用了内部方法或访问了内部属性，它往往会错过重要的模板逻辑和事件处理。</p>
</div>
<div class="paragraph">
<p>上面的白盒测试规范调用了 <code>increment</code> 方法，但没有测试相应的模板代码，即增加按钮。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;button (click)="increment()" data-testid="increment-button"&gt;+&lt;/button&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们完全从模板中删除增加按钮，该功能显然就会出现问题。但是白盒测试不会失败。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
优先进行黑盒测试
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当应用于 Angular 组件时，黑盒测试对于初学者来说更直观和更容易理解。在编写黑盒测试时，询问组件对用户和父组件做了什么，然后在测试中模仿使用情况。</p>
</div>
<div class="paragraph">
<p>白盒测试不仅从 DOM 视角严格地检查组件。因此，它存在错过关键组件行为的风险。它给人一种所有代码都经过测试的错觉。</p>
</div>
<div class="paragraph">
<p>也就是说，白盒测试是一种可行的高级技术。有经验的测试人员可以编写高效的白盒规范，仍然测试所有组件功能并覆盖所有代码。</p>
</div>
<div class="paragraph">
<p>下表显示了在黑盒测试中应该访问或不访问的 Angular 组件的属性和方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
推荐方式
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. 黑盒测试 Angular 组件</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类成员</th>
<th class="tableblock halign-left valign-top">测试中的访问</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Input</code> 属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是 (写入)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Output</code> 属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是 (订阅)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">生命周期方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">避免，除非是 <code>ngOnChanges</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">其他公共方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">避免</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">私有属性和方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不访问</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
