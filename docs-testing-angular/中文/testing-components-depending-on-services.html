<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>测试依赖于服务的组件 :: Testing Angular</title>
    <meta name="generator" content="Antora 3.1.14">
    <link rel="stylesheet" href="../../_/css/site.css">
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">Testing Angular</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs-testing-angular" data-version="中文">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="introduction.html">简介</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="target-audience.html">目标受众</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="terminology.html">术语</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-principles.html">测试原则</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="example-applications.html">示例应用程序</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="angular-testing-principles.html">Angular 测试原则</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="test-suites-with-jasmine.html">使用Jasmine编写测试套件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="faking-dependencies.html">伪造依赖</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="debugging-tests.html">调试测试</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components.html">测试组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components-with-children.html">测试带有子组件的组件</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="testing-components-depending-on-services.html">测试依赖于服务的组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-complex-forms.html">测试复杂表单</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-components-with-spectator.html">测试时使用Spectator库简化组件</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-services.html">测试服务</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-pipes.html">测试管道</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-directives.html">测试指令</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="testing-modules.html">测试模块</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="measuring-code-coverage.html">代码覆盖率测量</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="end-to-end-testing.html">端到端测试</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="summary.html">总结</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index-of-example-applications.html">示例应用程序索引</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="references.html">参考资料</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="acknowledgements.html">鸣谢</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="about.html">关于</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="license.html">许可证</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="other.html">其它</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Testing Angular</span>
    <span class="version">中文</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="start.html">Testing Angular</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="start.html">中文</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="start.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="start.html">Testing Angular</a></li>
    <li><a href="testing-components-depending-on-services.html">测试依赖于服务的组件</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="目录" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">测试依赖于服务的组件</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>学习目标</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在需要与服务交互的组件之间选择单元测试还是集成测试。</p>
</li>
<li>
<p>创建伪造服务以在隔离环境中测试组件。</p>
</li>
<li>
<p>验证组件与服务正确地交互。</p>
</li>
<li>
<p>了解不同的伪造服务依赖的方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们已经成功地测试了独立的 <code>CounterComponent</code> 和容器 <code>HomeComponent</code>。接下来我们要测试的组件是 <a href="https://github.com/9elements/angular-workshop/tree/main/src/app/components/service-counter">ServiceCounterComponent</a>。</p>
</div>
<button class="load-iframe">
观察 ServiceCounterComponent 的行为
</button>

<script type="text/x-template">
<p class="responsive-iframe">
<iframe src="https://9elements.github.io/angular-workshop/service-counter-component" class="responsive-iframe__iframe"></iframe>
</p>
</script>
<div class="paragraph">
<p>顾名思义，该组件依赖于 <code>CounterService</code>。计数状态不存储在组件本身，而是存储在中央服务中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
共享中央状态
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Angular 的依赖注入仅维护一个应用范围的服务实例，也就是所谓的单例。因此，多个 <code>ServiceCounterComponent</code> 实例共享相同的计数状态。如果用户在一个实例中增加计数，其他实例中的计数也会发生变化。</p>
</div>
<div class="paragraph">
<p>同样，对于该组件，有两种基本的测试方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用伪造对象替换 <code>CounterService</code> 依赖的单元测试。</p>
</li>
<li>
<p>包含真实 <code>CounterService</code> 的集成测试。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本指南将演示这两种方式。对于您的组件，您需要根据实际情况进行选择。以下问题可能会给您提供一些指导：哪种测试类型更有益、更有意义？哪种测试在设置和长期维护方面更容易？</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_服务依赖的集成测试"><a class="anchor" href="#_服务依赖的集成测试"></a>服务依赖的集成测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对于 <code>ServiceCounterComponent</code>，集成测试比单元测试更容易设置。简单的 <code>CounterService</code> 几乎没有逻辑，也没有其他依赖项。它没有我们需要在测试环境中抑制的副作用，例如 HTTP 请求。它只是改变了它的内部状态。</p>
</div>
<div class="paragraph">
<p>集成测试与我们已经编写的 <code>CounterComponent</code> 测试几乎相同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('ServiceCounterComponent: integration test', () =&gt; {
  let component: ServiceCounterComponent;
  let fixture: ComponentFixture&lt;ServiceCounterComponent&gt;;

  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      declarations: [ServiceCounterComponent],
      providers: [CounterService],
    }).compileComponents();

    fixture = TestBed.createComponent(ServiceCounterComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('shows the start count', () =&gt; {
    expectText(fixture, 'count', '0');
  });

  it('increments the count', () =&gt; {
    click(fixture, 'increment-button');
    fixture.detectChanges();
    expectText(fixture, 'count', '1');
  });

  it('decrements the count', () =&gt; {
    click(fixture, 'decrement-button');
    fixture.detectChanges();
    expectText(fixture, 'count', '-1');
  });

  it('resets the count', () =&gt; {
    const newCount = 456;
    setFieldValue(fixture, 'reset-input', String(newCount));
    click(fixture, 'reset-button');
    fixture.detectChanges();
    expectText(fixture, 'count', String(newCount));
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>与 <code>CounterComponent</code> 的测试相比，这里没有什么新的东西，除了一行代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">providers: [CounterService],</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
提供服务
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这行代码将 <code>CounterService</code> 添加到测试模块中。Angular 创建一个服务的实例并将其注入到要测试的组件中。这个测试比较简短，因为 <code>ServiceCounterComponent</code> 没有要测试的输入或输出。</p>
</div>
<div class="paragraph">
<p>由于 <code>CounterService</code> 总是以 count <code>0</code> 开始，测试需要默认使用这个初始计数。组件和服务都不允许使用不同的初始计数。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
与服务的交互
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>集成测试不会检查组件的内部工作方式。它只提供了服务，但不检查组件和服务之间的交互。组件可能根本不与服务进行通信。</p>
</div>
<div class="paragraph">
<p>如果我们想要一个集成测试来验证组件是否将计数存储在服务中，我们需要编写一个包含两个 <code>ServiceCounterComponent</code> 的测试：使用一个组件增加计数时，另一个组件中显示的计数应相应更改。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-workshop/blob/main/src/app/components/service-counter/service-counter.component.spec.ts">ServiceCounterComponent: 集成测试</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_虚拟服务依赖"><a class="anchor" href="#_虚拟服务依赖"></a>虚拟服务依赖</h2>
<div class="sectionbody">
<div class="paragraph">
<p>让我们继续进行 <code>ServiceCounterComponent</code> 的 <strong>单元测试</strong>。为了解决这个问题，我们需要学习如何虚拟化服务依赖。</p>
</div>
<div class="paragraph">
<p>有几种实际的方法，各有利弊。我们已经讨论了 <a href="faking-dependencies.html#_伪造依赖" class="xref page">伪造依赖</a> 的两个主要要求：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>虚拟与原始服务的等价性：虚拟必须具有派生自原始服务的类型。</p>
</li>
<li>
<p>有效的虚拟化：原始服务保持不变。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
推荐的虚拟化方法
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>本指南将介绍一种实现这些要求的解决方案。请注意，其他解决方案也可能满足这些要求。</p>
</div>
<div class="paragraph">
<p>我们需要虚拟化的依赖项 <code>CounterService</code> 是一个简单的类，带有 <code>@Injectable()</code> 注解。这是 <code>CounterService</code> 的外部形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">class CounterService {
  public getCount(): Observable&lt;number&gt; { /* … */ }
  public increment(): void { /* … */ }
  public decrement(): void { /* … */ }
  public reset(newCount: number): void { /* … */ }
  private notify(): void { /* … */ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们需要构建一个满足上述需求的虚拟对象。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
虚拟实例
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>创建一个简单的虚拟对象的最简单方法是使用对象字面量 <code>{…}</code> 和方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const currentCount = 123;
const fakeCounterService = {
  getCount() {
    return of(currentCount);
  },
  increment() {},
  decrement() {},
  reset() {},
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>getCount</code> 方法从名为 <code>currentCount</code> 的常量中返回一个固定值。我们稍后将使用该常量来检查组件是否正确使用了该值。</p>
</div>
<div class="paragraph">
<p>这个虚拟对象还远远不完美，但已经可以替代 <code>CounterService</code> 实例。它像原始对象一样行走和交谈。方法为空或返回固定数据。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
类型等价性
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上面的虚拟实现恰好具有与原始对象相同的形状。正如我们讨论的那样，让虚拟对象始终与原始对象保持同步非常重要。</p>
</div>
<div class="paragraph">
<p>目前，TypeScript还没有强制执行等价性。我们希望TypeScript能够检查虚拟对象是否正确地复制了原始对象。第一次尝试可以添加一个类型声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const fakeCounterService: CounterService = {
  getCount() {
    return of(currentCount);
  },
  increment() {},
  decrement() {},
  reset() {},
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>不幸的是，这样不起作用。TypeScript会报错说缺少私有方法和属性：</p>
</div>
<div class="paragraph">
<p><code>Type '{ getCount(): Observable&lt;number&gt;; increment(): void; decrement(): void; reset(): void; }' is missing the following properties from type 'CounterService': count, subject, notify</code></p>
</div>
<div class="paragraph">
<p>这是正确的。但我们不能在对象字面量中添加私有成员，也不应该这样做。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
挑选公共成员
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>幸运的是，我们可以使用 TypeScript 的一个技巧来解决这个问题。使用 <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys">Pick</a> 和 <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#index-types">keyof</a>，我们创建一个派生类型，该类型只包含公共成员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const fakeCounterService:
  Pick&lt;CounterService, keyof CounterService&gt; = {
  getCount() {
    return of(currentCount);
  },
  increment() {},
  decrement() {},
  reset() {},
};</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
保持 fake 与原始内容同步
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当 <code>CounterService</code> 改变其公共 API 时，依赖的 <code>ServiceCounterComponent</code> 需要进行调整。同样地，<code>fakeCounterService</code> 需要反映这些更改。类型声明会提醒您更新 fake。它防止 fake 与原始内容不同步。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
只 fake 必要的部分
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ServiceCounterComponent</code> 调用了 <code>CounterService</code> 的所有公共方法，因此我们已将它们添加到了 fake 中。</p>
</div>
<div class="paragraph">
<p>如果被测试的代码并未使用整个 API，那么 fake 也无需复制整个 API。只声明被测试代码实际使用的方法和属性即可。</p>
</div>
<div class="paragraph">
<p>例如，如果被测试的代码只调用了 <code>getCount</code>，只提供这个方法即可。确保添加一个类型声明，从原始类型中挑选出该方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const fakeCounterService: Pick&lt;CounterService, 'getCount'&gt; = {
  getCount() {
    return of(currentCount);
  },
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>挑选</code>和其他 <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types">映射类型</a>有助于以一种 TypeScript 可以检查等效性的方式将伪造类型与原始类型绑定。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
对方法进行监视
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>带有方法的普通对象是创建伪实例的一种简单方式。规范需要验证方法是否以正确的参数调用。</p>
</div>
<div class="paragraph">
<p><a href="faking-dependencies.html#_使用_jasmine_间谍伪造函数" class="xref page">Jasmine 间谍</a> 非常适合这项任务。首先的方法是用独立的间谍填充伪实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const fakeCounterService:
  Pick&lt;CounterService, keyof CounterService&gt; = {
  getCount:
    jasmine.createSpy('getCount').and.returnValue(of(currentCount)),
  increment: jasmine.createSpy('increment'),
  decrement: jasmine.createSpy('decrement'),
  reset: jasmine.createSpy('reset'),
};</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>createSpyObj</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这样做是可以的，但过于冗长。Jasmine 提供了一个便捷的辅助函数 <code>createSpyObj</code>，用于创建带有多个间谍方法的对象。它需要一个描述性名称和一个包含方法名称和返回值的对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const fakeCounterService = jasmine.createSpyObj&lt;CounterService&gt;(
  'CounterService',
  {
    getCount: of(currentCount),
    increment: undefined,
    decrement: undefined,
    reset: undefined,
  }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码创建了一个对象，其中包含四个方法，它们都是间谍。它们返回给定的值：<code>getCount</code> 返回一个 <code>Observable&lt;number&gt;</code>。其他方法返回 <code>undefined</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
类型等价性
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>createSpyObj</code> 接受一个 <a href="https://www.typescriptlang.org/docs/handbook/generics.html">TypeScript 类型变量</a>，用于声明所创建对象的类型。我们在尖括号中传递 <code>CounterService</code>，这样 TypeScript 就会检查伪实例是否与原始对象匹配。</p>
</div>
<div class="paragraph">
<p>让我们让我们的伪实例开始工作。在 <em>安排(Arrange)</em> 阶段，我们创建了伪实例并将其注入到测试模块中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('ServiceCounterComponent: unit test', () =&gt; {
  const currentCount = 123;

  let component: ServiceCounterComponent;
  let fixture: ComponentFixture&lt;ServiceCounterComponent&gt;;
  // Declare shared variable
  let fakeCounterService: CounterService;

  beforeEach(async () =&gt; {
    // Create fake
    fakeCounterService = jasmine.createSpyObj&lt;CounterService&gt;(
      'CounterService',
      {
        getCount: of(currentCount),
        increment: undefined,
        decrement: undefined,
        reset: undefined,
      }
    );

    await TestBed.configureTestingModule({
      declarations: [ServiceCounterComponent],
      // Use fake instead of original
      providers: [
        { provide: CounterService, useValue: fakeCounterService }
      ],
    }).compileComponents();

    fixture = TestBed.createComponent(ServiceCounterComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  /* … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>测试模块的 <code>提供者(providers)</code> 部分出现了一种新的模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">providers: [
  { provide: CounterService, useValue: fakeCounterService }
]</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
使用伪实例替代
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这是关键时刻，我们告诉 Angular：对于 <code>CounterService</code> 依赖项，请使用 <code>fakeCounterService</code> 这个值。这就是我们如何用伪实例替换原始实例。</p>
</div>
<div class="paragraph">
<p>通常情况下，当组件、服务等请求 <code>CounterService</code> 时，Angular 会实例化并注入一个 <code>CounterService</code> 实例。通过使用 <code>{ provide: …, useValue: … }</code>，我们跳过了实例化过程，直接提供要注入的值。</p>
</div>
<div class="paragraph">
<p>现在，<em>安排(Arrange)</em> 阶段已经完成，让我们来编写实际的规范。</p>
</div>
<div class="paragraph">
<p><em>行动(Act)</em> 阶段与其他计数器组件的测试相同：我们点击按钮并填写表单字段。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
验证间谍
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在 <em>断言(Assert)</em> 阶段，我们需要验证 Service 方法是否已被调用。由于使用了 <code>jasmine.createSpyObj</code>，<code>fakeCounterService</code> 的所有方法都是间谍。我们使用 <code>expect</code> 结合适当的匹配器，如 <code>toHaveBeenCalled</code>、<code>toHaveBeenCalledWith</code> 等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">expect(fakeCounterService.getCount).toHaveBeenCalled();</code></pre>
</div>
</div>
<div class="paragraph">
<p>应用于所有规范，测试套件的样子如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('ServiceCounterComponent: unit test', () =&gt; {
  const currentCount = 123;

  let component: ServiceCounterComponent;
  let fixture: ComponentFixture&lt;ServiceCounterComponent&gt;;
  // Declare shared variable
  let fakeCounterService: CounterService;

  beforeEach(async () =&gt; {
    // Create fake
    fakeCounterService = jasmine.createSpyObj&lt;CounterService&gt;(
      'CounterService',
      {
        getCount: of(currentCount),
        increment: undefined,
        decrement: undefined,
        reset: undefined,
      }
    );

    await TestBed.configureTestingModule({
      declarations: [ServiceCounterComponent],
      // Use fake instead of original
      providers: [
        { provide: CounterService, useValue: fakeCounterService }
      ],
    }).compileComponents();

    fixture = TestBed.createComponent(ServiceCounterComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('shows the count', () =&gt; {
    expectText(fixture, 'count', String(currentCount));
    expect(fakeCounterService.getCount).toHaveBeenCalled();
  });

  it('increments the count', () =&gt; {
    click(fixture, 'increment-button');
    expect(fakeCounterService.increment).toHaveBeenCalled();
  });

  it('decrements the count', () =&gt; {
    click(fixture, 'decrement-button');
    expect(fakeCounterService.decrement).toHaveBeenCalled();
  });

  it('resets the count', () =&gt; {
    const newCount = 456;
    setFieldValue(fixture, 'reset-input', String(newCount));
    click(fixture, 'reset-button');
    expect(fakeCounterService.reset).toHaveBeenCalledWith(newCount);
  });
});</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-workshop/tree/main/src/app/components/service-counter">ServiceCounterComponent：实现和测试代码</a></p>
</li>
<li>
<p><a href="https://angular.cn/guide/dependency-injection-providers">Angular 指南：依赖项提供者</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_具有最小逻辑的伪造服务"><a class="anchor" href="#_具有最小逻辑的伪造服务"></a>具有最小逻辑的伪造服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>上面的规范检查了用户交互是否调用了 Service 的方法。它们没有检查在调用 Service 后，组件是否重新呈现了新的计数。</p>
</div>
<div class="paragraph">
<p><code>ServiceCounter</code> 的 <code>getCount</code> 方法返回一个 <code>Observable&lt;number&gt;</code>，并且在计数发生变化时通过 Observable 推送新值。规范 <code>it('shows the count', …)</code> 已经证明组件从 Service 获取了计数并进行了渲染。</p>
</div>
<div class="paragraph">
<p>此外，我们还将检查在推送新值时组件是否进行了更新。在我们的简单 <code>ServiceCounterComponent</code> 和 <code>CounterService</code> 示例中，这并不是严格必要的。但是在组件与服务之间的更复杂交互中，这一点非常重要。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
组件更新
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>伪造的 <code>getCount</code> 方法返回 <code>of(currentCount)</code>，这是一个具有固定值 123 的 Observable。Observable 立即完成并且不会推送其他值。我们需要改变这种行为，以展示组件的更新。</p>
</div>
<div class="paragraph">
<p>迄今为止，缺乏逻辑的伪造 <code>CounterService</code> 需要获得一些逻辑。<code>getCount</code> 需要返回一个 Observable，在调用 <code>increment</code>、<code>decrement</code> 和 <code>reset</code> 时会发出新的值。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>BehaviorSubject</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们使用 <code>BehaviorSubject</code>，而不是固定的 Observable，就像原始的 <code>CounterService</code> 实现一样。<code>BehaviorSubject</code> 有一个 <code>next</code> 方法用于推送新值。</p>
</div>
<div class="paragraph">
<p>我们在测试套件的第一个 <code>beforeEach</code> 块中，在作用域中声明了一个名为 <code>fakeCount$</code> 的变量，并赋值为一个 <code>BehaviorSubject</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('ServiceCounterComponent: unit test with minimal Service logic', () =&gt; {
  /* … */
  let fakeCount$: BehaviorSubject&lt;number&gt;;

  beforeEach(async () =&gt; {
    fakeCount$ = new BehaviorSubject(0);
    /* … */
  });

  /* … */
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们更改 <code>fakeCounterService</code>，使得方法通过 <code>fakeCount$</code> 推送新的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const newCount = 123;
/* … */
fakeCounterService = {
  getCount(): Observable&lt;number&gt; {
    return fakeCount$;
  },
  increment(): void {
    fakeCount$.next(1);
  },
  decrement(): void {
    fakeCount$.next(-1);
  },
  reset(): void {
    fakeCount$.next(Number(newCount));
  },
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的伪实例是一个带有普通方法的对象。我们不再使用 <code>createSpyObj</code>，因为它不允许伪造方法的实现。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
对方法进行监视
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们丢失了 Jasmine 间谍，需要将它们重新引入。有几种方法可以将方法包装为间谍。为了简单起见，我们使用 <code>spyOn</code> 在所有方法上安装间谍：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">spyOn(fakeCounterService, 'getCount').and.callThrough();
spyOn(fakeCounterService, 'increment').and.callThrough();
spyOn(fakeCounterService, 'decrement').and.callThrough();
spyOn(fakeCounterService, 'reset').and.callThrough();</code></pre>
</div>
</div>
<div class="paragraph">
<p>记得添加 <code>.and.callThrough()</code>，这样底层的伪造方法才会被调用。</p>
</div>
<div class="paragraph">
<p>现在我们的伪服务向组件发送新的计数。我们可以重新引入对组件输出的检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">fixture.detectChanges();
expectText(fixture, 'count', '…');</code></pre>
</div>
</div>
<div class="paragraph">
<p>将所有部分组装在一起，完整的 <code>ServiceCounterComponent</code> 单元测试如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">describe('ServiceCounterComponent: unit test with minimal Service logic', () =&gt; {
  const newCount = 456;

  let component: ServiceCounterComponent;
  let fixture: ComponentFixture&lt;ServiceCounterComponent&gt;;

  let fakeCount$: BehaviorSubject&lt;number&gt;;
  let fakeCounterService: Pick&lt;CounterService, keyof CounterService&gt;;

  beforeEach(async () =&gt; {
    fakeCount$ = new BehaviorSubject(0);

    fakeCounterService = {
      getCount(): Observable&lt;number&gt; {
        return fakeCount$;
      },
      increment(): void {
        fakeCount$.next(1);
      },
      decrement(): void {
        fakeCount$.next(-1);
      },
      reset(): void {
        fakeCount$.next(Number(newCount));
      },
    };
    spyOn(fakeCounterService, 'getCount').and.callThrough();
    spyOn(fakeCounterService, 'increment').and.callThrough();
    spyOn(fakeCounterService, 'decrement').and.callThrough();
    spyOn(fakeCounterService, 'reset').and.callThrough();

    await TestBed.configureTestingModule({
      declarations: [ServiceCounterComponent],
      providers: [
        { provide: CounterService, useValue: fakeCounterService }
      ],
    }).compileComponents();

    fixture = TestBed.createComponent(ServiceCounterComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('shows the start count', () =&gt; {
    expectText(fixture, 'count', '0');
    expect(fakeCounterService.getCount).toHaveBeenCalled();
  });

  it('increments the count', () =&gt; {
    click(fixture, 'increment-button');
    fakeCount$.next(1);
    fixture.detectChanges();

    expectText(fixture, 'count', '1');
    expect(fakeCounterService.increment).toHaveBeenCalled();
  });

  it('decrements the count', () =&gt; {
    click(fixture, 'decrement-button');
    fakeCount$.next(-1);
    fixture.detectChanges();

    expectText(fixture, 'count', '-1');
    expect(fakeCounterService.decrement).toHaveBeenCalled();
  });

  it('resets the count', () =&gt; {
    setFieldValue(fixture, 'reset-input', newCount);
    click(fixture, 'reset-button');
    fixture.detectChanges();

    expectText(fixture, 'count', newCount);
    expect(fakeCounterService.reset).toHaveBeenCalledWith(newCount);
  });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次强调，此示例有意冗长。伪实例重新实现了原始逻辑的大部分。这是因为原始的 <code>CounterService</code> 本身逻辑较少。</p>
</div>
<div class="paragraph">
<p>实际上，服务更加复杂，组件会处理从服务接收到的数据。因此，伪造基本逻辑的工作是值得的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/9elements/angular-workshop/blob/main/src/app/components/service-counter/service-counter.component.spec.ts">ServiceCounterComponent：单元测试</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_伪造服务总结"><a class="anchor" href="#_伪造服务总结"></a>伪造服务：总结</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在测试 Angular 应用程序时，创建伪造服务依赖项并验证其使用是最具挑战性的问题之一。本指南只能对此主题进行简要介绍。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
可测试的服务
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>伪造服务需要付出努力并进行持续的实践。您编写的单元测试越多，您就会获得更多的经验。更重要的是，实践教会您编写简单的服务，<em>这些服务易于伪造</em>：具有明确的 API 和明显目的的服务。</p>
</div>
<div class="paragraph">
<p>不幸的是，对于伪造服务而言，并没有最佳实践。您会在网上找到很多方法，它们各有优势和劣势。相关的单元测试具有不同程度的准确性和完整性。</p>
</div>
<div class="paragraph">
<p>争论如何“正确“伪造服务是没有意义的。您需要根据具体情况决定适合服务的伪造方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
准则
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有两个准则可能对您有所帮助：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>测试是否有价值？它是否涵盖了组件和服务之间的重要交互？决定是浅显地测试还是深入地测试交互。</p>
</li>
<li>
<p>无论选择哪种方法，请确保满足 <a href="faking-dependencies.html#_伪造依赖" class="xref page">基本要求</a>：</p>
<div class="ulist">
<ul>
<li>
<p>1. 伪实例与原始实例等价：伪实例必须具有派生自原始实例的类型。</p>
</li>
<li>
<p>2. 有效的伪造：原始实例保持不变。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
